<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karawana Burrito</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game, if needed, overriding Tailwind */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Specific styling for the game board grid items for better visuals */
        .grid-item {
            width: 3rem; /* Fixed width for tiles */
            height: 3rem; /* Fixed height for tiles */
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.25rem; /* rounded-sm */
            text-align: center;
            font-size: 0.75rem; /* text-xs */
        }

        /* Responsive adjustments for larger screens if necessary, overriding fixed size */
        @media (min-width: 768px) {
            .grid-item {
                width: 4rem; /* Larger tiles on medium screens */
                height: 4rem;
                font-size: 0.875rem; /* text-sm */
            }
        }
        @media (min-width: 1024px) {
            .grid-item {
                width: 5rem; /* Even larger tiles on large screens */
                height: 5rem;
                font-size: 1rem; /* text-base */
            }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div id="game-container" class="flex flex-col lg:flex-row gap-8 w-full max-w-6xl">
        <!-- Sidebar - Player Info and Game Log -->
        <div class="lg:w-1/3 flex flex-col gap-4">
            <!-- Player Info -->
            <div class="bg-white rounded-lg shadow-md p-4">
                <h2 class="text-xl font-semibold mb-3 text-blue-700">Gracze</h2>
                <div id="players-info">
                    <!-- Player info will be rendered here by JavaScript -->
                </div>
            </div>

            <!-- Game Log -->
            <div class="bg-white rounded-lg shadow-md p-4 flex-grow overflow-y-auto max-h-60 lg:max-h-[300px]">
                <h2 class="text-xl font-semibold mb-3 text-blue-700">Log Gry</h2>
                <div id="game-log" class="text-sm space-y-1">
                    <!-- Game log messages will be added here by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Main Game Area - Board and Controls -->
        <div class="lg:w-2/3 flex flex-col gap-6">
            <!-- Game Board -->
            <div class="bg-white rounded-lg shadow-md p-4">
                <h2 class="text-xl font-semibold mb-3 text-blue-700">Plansza</h2>
                <div id="game-board" class="grid gap-0.5" style="grid-template-columns: repeat(7, minmax(0, 1fr));">
                    <!-- Game board tiles will be rendered here by JavaScript -->
                </div>
            </div>

            <!-- Game Controls -->
            <div class="bg-white rounded-lg shadow-md p-4 flex flex-col sm:flex-row gap-4 justify-center items-center">
                <button id="next-turn-button" class="px-6 py-3 bg-blue-600 text-white font-bold rounded-lg shadow-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                    Wykonaj Ruch
                </button>
                <p id="game-status" class="text-lg font-semibold text-gray-700 mt-2"></p>
                <button id="restart-button" class="px-6 py-3 bg-green-600 text-white font-bold rounded-lg shadow-lg hover:bg-green-700 transition-colors hidden">
                    Zagraj Ponownie
                </button>
            </div>

            <!-- Legend -->
            <div class="bg-white rounded-lg shadow-md p-4">
                <h2 class="text-xl font-semibold mb-3 text-blue-700">Legenda</h2>
                <div id="legend-info" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 text-sm">
                    <!-- Legend items will be rendered here by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- GAME CONSTANTS ---
        const BOARD_SIZE = 7;

        // --- GAME CLASSES AND OBJECTS ---

        // Tile class/object
        const Pole = (type, symbol, bonus = null) => ({ type, symbol, bonus });

        // Donkey class/object
        const Osiolek = (type) => ({ type });

        // Player class/object
        const Gracz = (name, leaderSymbol, caravanSymbol, startX, startY, isAI = false) => ({
            name,
            leaderSymbol,
            caravanSymbol,
            caravan: [{ x: startX, y: startY, osiolek: Osiolek('zwykly') }], // List of caravan segments
            points: 0,
            packages: [], // List of package names
            losesTurn: 0, // Number of turns to lose
            extraMoveNextTurn: 0, // Extra movement bonus for next turn
            donkeyAbilities: [], // List of ability types (e.g., 'twardziel', 'zlodziej')
            equipment: [], // List of owned equipment (e.g., 'siodlo', 'sakwa')
            isAI,
            shadowCooldown: 0, // Cooldown for 'cien' donkey ability
            amuletActiveTurns: 0, // Turns Amulet is active for trap/bandit immunity
            mapaBonusActive: false, // Permanent +1 movement from Mapa
        });

        // --- GAME LOGIC FUNCTIONS ---

        // Board initialization
        const initializeBoard = (size) => {
            const board = Array.from({ length: size }, () => Array(size).fill(null).map(() => Pole('empty', '.')));

            // Packages (mixed types including new ones)
            board[1][1] = Pole('package', '📦', { points: 10, name: 'Wino' });
            board[5][5] = Pole('package', '📦', { points: 15, name: 'Przyprawy' });
            board[0][0] = Pole('package', '✨', { points: 5, name: 'Amulet' }); // New Amulet package
            board[6][0] = Pole('package', '🗺️', { points: 5, name: 'Mapa' });    // New Mapa package

            // Loose Donkeys
            board[2][5] = Pole('donkey', '🐴');

            // Food
            board[2][3] = Pole('food', '🍎');
            board[5][3] = Pole('food', '🍎');

            // Traps
            board[3][3] = Pole('trap', '☠️', { turnsLost: 1 });

            // Vineyards
            board[0][2] = Pole('vineyard', '🍇');
            board[6][4] = Pole('vineyard', '🍇');

            // Mountain Shortcuts (shortcut to package at (1,1))
            board[3][0] = Pole('mountain_shortcut', '🏔️', { targetX: 1, targetY: 1 });

            // Cacti
            board[4][1] = Pole('cactus', '🌵');

            // River and Bridges
            board[3][1] = Pole('river', '🌊');
            board[4][2] = Pole('bridge', '🌉');
            board[5][2] = Pole('river', '🌊');

            // Bazaar
            board[0][6] = Pole('bazar', '💰');

            // Fences
            board[2][2] = Pole('fence', '🚧');
            board[4][4] = Pole('fence', '🚧');

            // New: Bandolero (Bandits)
            board[1][3] = Pole('bandits', '🤠', { packagesLost: 1, donkeysLost: 1 });
            board[5][1] = Pole('bandits', '🤠', { packagesLost: 1, donkeysLost: 1 });

            // New: Well
            board[4][6] = Pole('well', '💧'); // Can give bonus or penalty
            board[1][6] = Pole('well', '💧');

            // New: Oasis
            board[6][3] = Pole('oasis', '🌴');
            board[0][3] = Pole('oasis', '🌴');


            // Special Donkeys (unique)
            board[1][5] = Pole('special_donkey', '⚪', { donkeyType: 'guide', name: 'Bialy Osiolek' }); // Guide Donkey
            board[4][0] = Pole('special_donkey', '⚫', { donkeyType: 'shadow', name: 'Czarny Osiolek' }); // Shadow Donkey
            board[6][1] = Pole('special_donkey', '🟫', { donkeyType: 'sturdy', name: 'Brazowy Osiolek' }); // Sturdy Donkey
            board[0][4] = Pole('special_donkey', '⬜', { donkeyType: 'stealthy', name: 'Szary Osiolek' }); // Stealthy Donkey (not active in this version)

            return board;
        };

        // Manhattan distance calculation (used in AI)
        const calculateManhattanDistance = (x1, y1, x2, y2) => Math.abs(x1 - x2) + Math.abs(y1 - y2);

        // Checks if a player has a specific donkey ability
        const hasAbility = (player, abilityType) => player.donkeyAbilities.includes(abilityType);

        // Checks if a player has specific equipment
        const hasEquipment = (player, equipmentType) => player.equipment.includes(equipmentType);

        // Handles actions after landing on a tile
        const handleTileAction = (player, board, playersList) => {
            const { x, y } = player.caravan[0];
            const tile = board[x][y];
            let newLog = [];

            newLog.push(`  ${player.name} wszedl na pole: ${tile.type} (${tile.symbol})`);

            switch (tile.type) {
                case 'package':
                    player.points += tile.bonus.points;
                    player.packages.push(tile.bonus.name);
                    newLog.push(`  ${player.name} zebral pakunek '${tile.bonus.name}'! Zdobyl ${tile.bonus.points} punktow.`);
                    
                    // Special package effects
                    if (tile.bonus.name === 'Amulet') {
                        player.amuletActiveTurns = 3;
                        newLog.push(`  ${player.name} aktywowal Amulet! Chroniony przed pulapkami i Bandytami przez 3 tury.`);
                    } else if (tile.bonus.name === 'Mapa') {
                        player.mapaBonusActive = true;
                        newLog.push(`  ${player.name} znalazl Mape! Zyskuje +1 staly ruch.`);
                    }
                    board[x][y] = Pole('empty', '.'); // Package disappears
                    break;
                case 'donkey':
                    newLog.push(`  ${player.name} znalazl luznego osiolka! Dolacza go do karawany.`);
                    player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek('zwykly') });
                    board[x][y] = Pole('empty', '.'); // Donkey disappears
                    break;
                case 'special_donkey':
                    newLog.push(`  ${player.name} znalazl ${tile.bonus.name}! Dolacza go do karawany.`);
                    player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek(tile.bonus.donkeyType) });
                    player.donkeyAbilities.push(tile.bonus.donkeyType);
                    newLog.push(`  --> ${player.name} zdobywa umiejetnosc: ${tile.bonus.donkeyType.charAt(0).toUpperCase() + tile.bonus.donkeyType.slice(1)}!`);
                    board[x][y] = Pole('empty', '.'); // Special donkey disappears
                    break;
                case 'food':
                    newLog.push(`  ${player.name} wszedl na pole z jedzeniem! Rozmnazanie karawany...`);
                    const donkeyTypes = ['zwykly', 'twardziel', 'zlodziej', 'prorok', 'wloczega'];
                    const newDonkeyType = donkeyTypes[Math.floor(Math.random() * donkeyTypes.length)];
                    player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek(newDonkeyType) });
                    if (newDonkeyType !== 'zwykly') {
                        player.donkeyAbilities.push(newDonkeyType);
                        newLog.push(`  Nowy osiolek dolaczony! Typ: ${newDonkeyType.charAt(0).toUpperCase() + newDonkeyType.slice(1)}!`);
                    } else {
                        newLog.push(`  Nowy osiolek dolaczony! Typ: Zwykly.`);
                    }
                    board[x][y] = Pole('empty', '.'); // Food disappears
                    break;
                case 'trap':
                    if (player.amuletActiveTurns > 0) {
                        newLog.push(`  ${player.name} wszedl w pulapke, ale zostal ochroniony przez Amulet!`);
                    } else if (!hasAbility(player, 'twardziel')) {
                        player.losesTurn += tile.bonus.turnsLost;
                        newLog.push(`  ${player.name} wpadl w pulapke! Traci ${tile.bonus.turnsLost} ture/tury.`);
                    } else {
                        newLog.push(`  ${player.name} wszedl w pulapke, ale jego Sturdy Donkey go uratowal!`);
                    }
                    break;
                case 'vineyard':
                    player.extraMoveNextTurn += 1;
                    newLog.push(`  ${player.name} wszedl na winnice! Zyskuje +1 ruch w nastepnej turze.`);
                    break;
                case 'mountain_shortcut':
                    const { targetX, targetY } = tile.bonus;
                    newLog.push(`  ${player.name} uzyl gorskiego skrotu! Przeniosl sie na pole (${targetX + 1}, ${targetY + 1}).`);
                    // Teleport head
                    const currentHeadOsiolek = player.caravan[0].osiolek;
                    player.caravan[0] = { x: targetX, y: targetY, osiolek: currentHeadOsiolek };
                    // Other donkeys follow (simplified: appear behind leader at new location)
                    for (let i = 1; i < player.caravan.length; i++) {
                        const prevSeg = player.caravan[i - 1];
                        player.caravan[i] = {
                            x: prevSeg.x - (prevSeg.x > 0 ? 1 : 0), // Simple trailing logic
                            y: prevSeg.y,
                            osiolek: player.caravan[i].osiolek
                        };
                    }
                    break;
                case 'bazaar':
                    newLog.push(`  ${player.name} jest na Bazarze. Tutaj mozesz sprzedac pakunki (5 pts/each)!`);
                    if (player.packages.length > 0) {
                        const soldPackage = player.packages.pop();
                        player.points += 5;
                        newLog.push(`  ${player.name} sprzedal '${soldPackage}' za 5 punktow.`);
                    } else {
                        newLog.push("  Nie masz pakunkow do sprzedania.");
                    }
                    break;
                case 'cactus':
                    newLog.push(`  ${player.name} wszedl na kaktusa! Ruch w nastepnej turze moze byc spowolniony.`);
                    break;
                case 'river':
                    newLog.push(`  ${player.name} wszedl na rzeke! To pole jest nieprzechodnie.`);
                    player.losesTurn += 1; // Penalty for entering impassable tile
                    break;
                case 'fence':
                    newLog.push(`  ${player.name} wszedl na plot! To pole jest nieprzechodnie.`);
                    player.losesTurn += 1; // Penalty for entering impassable tile
                    break;
                case 'bandits': // New Bandolero tile logic
                    if (player.amuletActiveTurns > 0) {
                        newLog.push(`  ${player.name} spotkal Bandytow, ale zostal ochroniony przez Amulet!`);
                    } else if (hasAbility(player, 'sturdy')) {
                        newLog.push(`  ${player.name} spotkal Bandytow, ale jego Sturdy Donkey odstraszyl ich!`);
                    } else {
                        const lostItemType = Math.random() < 0.5 ? 'package' : 'donkey';
                        if (lostItemType === 'package' && player.packages.length > 0) {
                            const lostPackage = player.packages.pop();
                            newLog.push(`  ${player.name} spotkal Bandytow! Stracil pakunek: '${lostPackage}'.`);
                        } else if (lostItemType === 'donkey' && player.caravan.length > 1) {
                            const lostDonkey = player.caravan.pop();
                            newLog.push(`  ${player.name} spotkal Bandytow! Stracil osiolka.`);
                        } else {
                            newLog.push(`  ${player.name} spotkal Bandytow, ale nic nie stracil (brak pakunkow/osiolkow).`);
                        }
                    }
                    break;
                case 'well': // New Well tile logic
                    const wellOutcome = Math.random();
                    if (wellOutcome < 0.4) { // 40% chance for bonus donkey
                        newLog.push(`  ${player.name} znalazl Studnie! Zyskuje nowego osiolka!`);
                        const donkeyTypes = ['zwykly', 'twardziel', 'zlodziej'];
                        const newDonkeyType = donkeyTypes[Math.floor(Math.random() * donkeyTypes.length)];
                        player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek(newDonkeyType) });
                        if (newDonkeyType !== 'zwykly') {
                            player.donkeyAbilities.push(newDonkeyType);
                            newLog.push(`  Nowy osiolek dolaczony! Typ: ${newDonkeyType.charAt(0).toUpperCase() + newDonkeyType.slice(1)}!`);
                        }
                    } else if (wellOutcome < 0.7) { // 30% chance for extra move next turn
                        newLog.push(`  ${player.name} znalazl Studnie! Zyskuje +1 ruch w nastepnej turze.`);
                        player.extraMoveNextTurn += 1;
                    } else { // 30% chance for losing a turn
                        newLog.push(`  ${player.name} znalazl Studnie! Niestety, traci 1 ture.`);
                        player.losesTurn += 1;
                    }
                    break;
                case 'oasis': // New Oasis tile logic
                    newLog.push(`  ${player.name} wszedl na Oaze! Zyskuje +1 ruch w tej turze!`);
                    // This bonus is applied immediately for calculation, then reset.
                    player.extraMoveNextTurn += 1; // This will be consumed by calculatePossibleMoves for the current turn
                    break;
                default:
                    break;
            }

            // 'Zlodziej' (Thief) Donkey activation (if player has it and another player has packages)
            if (hasAbility(player, 'zlodziej')) {
                if (Math.random() < 0.2) { // 20% chance to activate thief ability
                    newLog.push(`  ${player.name} probuje aktywowac Thief Donkey...`);
                    for (const otherPlayer of playersList) {
                        if (otherPlayer !== player && otherPlayer.packages.length > 0) {
                            const stolenPackage = otherPlayer.packages.pop();
                            player.packages.push(stolenPackage);
                            player.points += 5; // Bonus for stealing
                            newLog.push(`  --> SUKCES! ${player.name} ukradl '${stolenPackage}' od ${otherPlayer.name}! Zyskal 5 punktow.`);
                            break;
                        }
                    }
                }
            }
            gameLog.push(...newLog); // Add new logs to the main game log
            updateGameLogUI();
        };

        // Calculates possible moves for a player
        const calculatePossibleMoves = (player, board, size) => {
            const { x: currentX, y: currentY } = player.caravan[0];
            let possibleMoves = [];
            let baseMovement = 2; // Default movement

            // Add movement bonus from vineyard, equipment, or Mapa
            baseMovement += player.extraMoveNextTurn; // Consumed here for the current turn
            if (hasEquipment(player, 'sakwa')) {
                baseMovement += 1;
            }
            if (player.mapaBonusActive) { // Permanent +1 movement from Mapa
                baseMovement += 1;
            }
            
            // Note: player.extraMoveNextTurn is reset in nextTurn() after the move, not here.
            // This ensures Oasis bonus is applied to *this* turn's movement calculation,
            // but cleared before the next turn.

            // Ensure movement is not less than 1
            const actualMovement = Math.max(1, baseMovement);

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // Up, Down, Right, Left

            for (const [dx, dy] of directions) {
                for (let step = 1; step <= actualMovement; step++) {
                    const nextX = currentX + dx * step;
                    const nextY = currentY + dy * step;

                    if (nextX >= 0 && nextX < size && nextY >= 0 && nextY < size) {
                        const tile = board[nextX][nextY];
                        let cost = step;

                        // Cactus costs 1 extra move, unless player has 'wloczega' or 'przewodnik' ability
                        if (tile.type === 'cactus' && !hasAbility(player, 'wloczega') && !hasAbility(player, 'przewodnik')) {
                            cost += 1;
                        }
                        
                        // River and Fence are impassable, unless it's a Bridge
                        let blockedPath = false;
                        for (let i = 1; i <= step; i++) {
                            const intermediateX = currentX + dx * i;
                            const intermediateY = currentY + dy * i;
                            if (intermediateX < 0 || intermediateX >= size || intermediateY < 0 || intermediateY >= size) {
                                blockedPath = true; // Path out of bounds is blocked
                                break;
                            }
                            const intermediateTile = board[intermediateX][intermediateY];
                            if (intermediateTile.type === 'fence' || (intermediateTile.type === 'river' && intermediateTile.type !== 'bridge')) {
                                blockedPath = true;
                                break;
                            }
                        }
                        if(blockedPath) continue; // Don't add this move if the path is blocked
                        
                        if (cost <= actualMovement) {
                            possibleMoves.push({ x: nextX, y: nextY, cost: cost });
                        }
                    }
                }
            }
            return possibleMoves;
        };

        // AI movement logic
        const aiMove = (player, board, playersList, size) => {
            const { x: currentX, y: currentY } = player.caravan[0];
            let currentTurnPossibleMoves = calculatePossibleMoves(player, board, size); // AI calculates its moves
            
            // After calculating possible moves, reset extraMoveNextTurn for this player
            // This ensures Oasis bonus is consumed for this AI player's turn only.
            player.extraMoveNextTurn = 0;


            if (currentTurnPossibleMoves.length === 0) {
                gameLog.push(`  ${player.name} (AI) has no possible moves.`);
                updateGameLogUI();
                return;
            }

            let bestMove = null;
            let highestPriority = -Infinity;

            for (const move of currentTurnPossibleMoves) {
                const { x: targetX, y: targetY } = move;
                const tile = board[targetX][targetY];
                let priority = 0;

                // AI Priorities
                switch (tile.type) {
                    case 'package':
                        priority = 10; // Highest priority for packages
                        if (tile.bonus.name === 'Amulet') priority = 12; // Even higher for Amulet
                        if (tile.bonus.name === 'Mapa') priority = 11; // High for Mapa
                        if (hasEquipment(player, 'siodlo') && player.packages.length >= player.caravan.length * 2) priority = 1;
                        else if (player.packages.length >= player.caravan.length) priority = 1;
                        break;
                    case 'special_donkey':
                        priority = 9;
                        break;
                    case 'food':
                        priority = 8;
                        if (player.caravan.length >= 5) priority = 2;
                        break;
                    case 'donkey':
                        priority = 7;
                        if (player.caravan.length >= 5) priority = 1;
                        break;
                    case 'bazaar':
                        priority = player.packages.length > 0 ? 6 : 0;
                        break;
                    case 'vineyard':
                        priority = 5;
                        break;
                    case 'mountain_shortcut':
                        const { targetX: shortcutTargetX, targetY: shortcutTargetY } = tile.bonus;
                        if (shortcutTargetX !== undefined && shortcutTargetY !== undefined && shortcutTargetX >= 0 && shortcutTargetX < size && shortcutTargetY >= 0 && shortcutTargetY < size) {
                            const shortcutTargetTile = board[shortcutTargetX][shortcutTargetY];
                            if (shortcutTargetTile && (shortcutTargetTile.type === 'package' || shortcutTargetTile.type === 'food' || shortcutTargetTile.type === 'donkey' || shortcutTargetTile.type === 'special_donkey')) {
                                priority = 9.5;
                            }
                        } else {
                            priority = 4;
                        }
                        break;
                    case 'trap':
                        if (player.amuletActiveTurns > 0 || hasAbility(player, 'twardziel')) {
                            priority = 3; // Safe if protected
                        } else {
                            priority = -10; // Very low if vulnerable
                        }
                        break;
                    case 'bandits': // AI logic for Bandolero
                        if (player.amuletActiveTurns > 0 || hasAbility(player, 'sturdy')) {
                            priority = 4; // Safe to pass
                        } else {
                            priority = -8; // Avoid if vulnerable
                        }
                        break;
                    case 'well': // AI logic for Well
                        priority = 6; // Moderate priority for potential bonus
                        break;
                    case 'oasis': // AI logic for Oasis
                        priority = 7.5; // High priority for immediate movement bonus
                        break;
                    default:
                        priority = 0;
                        break;
                }

                priority -= (calculateManhattanDistance(currentX, currentY, targetX, targetY) * 0.1);

                if (priority > highestPriority) {
                    highestPriority = priority;
                    bestMove = move;
                }
            }

            if (bestMove) {
                const oldCaravan = JSON.parse(JSON.stringify(player.caravan));
                player.caravan[0] = { x: bestMove.x, y: bestMove.y, osiolek: oldCaravan[0].osiolek };
                for (let i = 1; i < player.caravan.length; i++) {
                    player.caravan[i] = { ...oldCaravan[i - 1], osiolek: oldCaravan[i].osiolek };
                }

                gameLog.push(`  ${player.name} (AI) moves to (${bestMove.x + 1}, ${bestMove.y + 1}).`);
                handleTileAction(player, board, playersList);
            } else {
                const safeMoves = currentTurnPossibleMoves.filter(move => {
                    const tile = board[move.x][move.y];
                    const isTrapSafe = tile.type !== 'trap' || player.amuletActiveTurns > 0 || hasAbility(player, 'twardziel');
                    const isBanditSafe = tile.type !== 'bandits' || player.amuletActiveTurns > 0 || hasAbility(player, 'sturdy');
                    const isImpassable = tile.type === 'fence' || (tile.type === 'river' && tile.type !== 'bridge');
                    return isTrapSafe && isBanditSafe && !isImpassable;
                });
                if (safeMoves.length > 0) {
                    const randomMove = safeMoves[Math.floor(Math.random() * safeMoves.length)];
                    const oldCaravan = JSON.parse(JSON.stringify(player.caravan));
                    player.caravan[0] = { x: randomMove.x, y: randomMove.y, osiolek: oldCaravan[0].osiolek };
                    for (let i = 1; i < player.caravan.length; i++) {
                        player.caravan[i] = { ...oldCaravan[i - 1], osiolek: oldCaravan[i].osiolek };
                    }
                    gameLog.push(`  ${player.name} (AI) makes a random safe move to (${randomMove.x + 1}, ${randomMove.y + 1}).`);
                    handleTileAction(player, board, playersList);
                } else {
                     gameLog.push(`  ${player.name} (AI) has no safe moves and stays put.`);
                }
            }
            updateGameLogUI();
        };

        // --- GLOBAL GAME STATE ---
        let board = [];
        let players = [];
        let currentPlayerIndex = 0;
        let gameLog = [];
        let gameOver = false;
        let winner = null;
        let selectedMove = null; // For normal player movement selection
        let selectedPackageForRelocation = null; // For Shadow Donkey ability
        let possibleMoves = [];

        // --- UI ELEMENTS ---
        const gameBoardElement = document.getElementById('game-board');
        const playersInfoElement = document.getElementById('players-info');
        const gameLogElement = document.getElementById('game-log');
        const nextTurnButton = document.getElementById('next-turn-button');
        const gameStatusElement = document.getElementById('game-status');
        const restartButton = document.getElementById('restart-button');
        const legendInfoElement = document.getElementById('legend-info');

        const legendData = [
            { symbol: '🔵/🔴', description: 'Start Gracza' },
            { symbol: '📦', description: 'Pakunek (punkty)' },
            { symbol: '✨', description: 'Pakunek Amulet (ochrona przed pułapkami/bandytami)' }, // Updated description
            { symbol: '🗺️', description: 'Pakunek Mapa (+1 stały ruch)' },                        // Updated description
            { symbol: '🐴', description: 'Luźny Osiołek (+1 do karawany)' },
            { symbol: '🍎', description: 'Jedzenie (rozmnożenie karawany)' },
            { symbol: '☠️', description: 'Pułapka (tracisz turę)' },
            { symbol: '🤠', description: 'Bandolero (tracisz osiołka/pakunek)' },
            { symbol: '💧', description: 'Studnia (bonus/kara)' },
            { symbol: '🌴', description: 'Oaza (+1 ruch w tej turze)' },
            { symbol: '🍇', description: 'Winnica (+1 ruch w nast. turze)' },
            { symbol: '🏔️', description: 'Górski Skrót (teleportacja)' },
            { symbol: '🌵', description: 'Kaktus (+1 koszt ruchu)' },
            { symbol: '🌊', description: 'Rzeka (nieprzechodnia)' },
            { symbol: '🌉', description: 'Most' },
            { symbol: '💰', description: 'Bazar (sprzedaż pakunków)' },
            { symbol: '🚧', description: 'Płot (nieprzechodnia bariera)' },
            { symbol: '⚪', description: 'Biały Osiołek (ignoruje kary ruchu)' },
            { symbol: '⚫', description: 'Czarny Osiołek (przesuwa pakunek co 3 tury)' },
            { symbol: '🟫', description: 'Brązowy Osiołek (ochrona przed Bandolero)' }, // Updated description
            { symbol: '⬜', description: 'Szary Osiołek (niewidzialny - nieaktywny)' },
            { symbol: '.', description: 'Puste Pole' },
        ];


        // --- GAME INITIALIZATION ---
        function startGame() {
            board = initializeBoard(BOARD_SIZE);
            players = [
                Gracz("Burrito", "🔵", "🟦", 0, 0, false), // Human player
                Gracz("Czerwony", "🔴", "🟥", BOARD_SIZE - 1, BOARD_SIZE - 1, true)  // AI player
            ];
            players[0].equipment.push('sakwa');
            // players[1].equipment.push('siodlo'); // AI starts with saddle (removed for more dynamic play)

            currentPlayerIndex = 0;
            gameLog = ["--- Rozpoczynamy Karawane Burrito! ---"];
            gameOver = false;
            winner = null;
            selectedMove = null;
            selectedPackageForRelocation = null; // Reset this on game start
            possibleMoves = [];

            renderGame();
            nextTurnButton.classList.remove('hidden');
            restartButton.classList.add('hidden');
            gameStatusElement.textContent = '';
        }

        // --- UI RENDERING FUNCTIONS ---

        // Renders the game board
        function renderGameBoard() {
            gameBoardElement.innerHTML = ''; // Clear board
            board.forEach((row, rIdx) => {
                row.forEach((tile, cIdx) => {
                    const tileDiv = document.createElement('div');
                    tileDiv.classList.add('grid-item', 'bg-gray-50');

                    // Highlight possible moves for human player
                    if (!players[currentPlayerIndex].isAI && possibleMoves.some(m => m.x === rIdx && m.y === cIdx)) {
                        tileDiv.classList.add('bg-green-200', 'cursor-pointer', 'hover:bg-green-300');
                        tileDiv.onclick = () => handleTileClick(rIdx, cIdx);
                    } else { // For AI or if no possible moves, remove interactive classes
                        tileDiv.classList.remove('cursor-pointer', 'hover:bg-green-300');
                        tileDiv.onclick = null;
                    }

                    // Highlight selected move (for normal movement)
                    if (selectedMove && selectedMove.x === rIdx && selectedMove.y === cIdx) {
                        tileDiv.classList.add('bg-yellow-300');
                    }
                    // Highlight selected package for relocation (Shadow Donkey)
                    else if (selectedPackageForRelocation && selectedPackageForRelocation.x === rIdx && selectedPackageForRelocation.y === cIdx) {
                        tileDiv.classList.add('bg-purple-300'); // Different highlight for selected package
                    }

                    // Get content for the tile (player or tile symbol)
                    let tileContent = tile.symbol;
                    for (const player of players) {
                        // Leader
                        if (player.caravan[0].x === rIdx && player.caravan[0].y === cIdx) {
                            tileContent = `<span class="font-bold text-lg">${player.leaderSymbol}${player.caravan.length}</span>`;
                            if (player.name === "Burrito") tileDiv.classList.add('text-blue-700');
                            if (player.name === "Czerwony") tileDiv.classList.add('text-red-700');
                            break;
                        }
                        // Caravan segments
                        else if (player.caravan.slice(1).some(seg => seg.x === rIdx && seg.y === cIdx)) {
                            tileContent = `<span class="text-sm">${player.caravanSymbol}</span>`;
                            if (player.name === "Burrito") tileDiv.classList.add('text-blue-500');
                            if (player.name === "Czerwony") tileDiv.classList.add('text-red-500');
                            break;
                        }
                    }

                    tileDiv.innerHTML = tileContent;
                    gameBoardElement.appendChild(tileDiv);
                });
            });
        }

        // Renders player information
        function renderPlayersInfo() {
            playersInfoElement.innerHTML = '';
            players.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.classList.add('mb-4', 'p-3', 'rounded-md', 'border');
                if (currentPlayerIndex === index) {
                    playerDiv.classList.add('bg-blue-100', 'border-blue-500', 'border-2');
                } else {
                    playerDiv.classList.add('bg-gray-50', 'border-gray-200');
                }

                playerDiv.innerHTML = `
                    <h3 class="text-lg font-bold flex items-center gap-2">
                        ${player.leaderSymbol} ${player.name} ${player.isAI ? '<span class="text-xs text-gray-600">(AI)</span>' : ''}
                    </h3>
                    <p>Punkty: <span class="font-semibold">${player.points}</span></p>
                    <p>Karawana: <span class="font-semibold">${player.caravan.length} osiołków</span></p>
                    <p>Pakunki: <span class="font-semibold">${player.packages.join(', ') || 'Brak'}</span></p>
                    ${player.donkeyAbilities.length > 0 ? `<p>Umiejętności Osiołków: <span class="font-semibold">${player.donkeyAbilities.join(', ')}</span></p>` : ''}
                    ${player.equipment.length > 0 ? `<p>Ekwipunek: <span class="font-semibold">${player.equipment.join(', ')}</span></p>` : ''}
                    ${player.losesTurn > 0 ? `<p class="text-red-600 font-semibold">Tracisz ${player.losesTurn} turę/tury!</p>` : ''}
                    ${player.amuletActiveTurns > 0 ? `<p class="text-purple-600 font-semibold">Amulet aktywny: ${player.amuletActiveTurns} tura/tury!</p>` : ''}
                    ${player.mapaBonusActive ? `<p class="text-yellow-600 font-semibold">Bonus z Mapy: +1 ruch!</p>` : ''}
                    ${player.shadowCooldown > 0 ? `<p class="text-gray-600 font-semibold">Czarny Osiołek: ${player.shadowCooldown} tura/tury do odnowienia.</p>` : ''}
                `;
                playersInfoElement.appendChild(playerDiv);
            });
        }

        // Updates the game log UI
        function updateGameLogUI() {
            gameLogElement.innerHTML = '';
            // Display last 10 log entries
            const displayLog = gameLog.slice(Math.max(gameLog.length - 10, 0));
            displayLog.forEach(message => {
                const p = document.createElement('p');
                p.classList.add('bg-gray-50', 'p-1', 'rounded-sm');
                p.textContent = message;
                gameLogElement.appendChild(p);
            });
            gameLogElement.scrollTop = gameLogElement.scrollHeight; // Scroll to bottom
        }

        // Renders the legend
        function renderLegend() {
            legendInfoElement.innerHTML = '';
            legendData.forEach(item => {
                const div = document.createElement('div');
                div.classList.add('flex', 'items-center', 'gap-2', 'p-1', 'bg-gray-50', 'rounded-sm');
                div.innerHTML = `<span class="font-semibold">${item.symbol}</span> <span>${item.description}</span>`;
                legendInfoElement.appendChild(div);
            });
        }

        // Main rendering function
        function renderGame() {
            renderPlayersInfo();
            // Possible moves are calculated *before* rendering the board
            // This ensures they are up-to-date for the current player
            if (!players[currentPlayerIndex].isAI) {
                possibleMoves = calculatePossibleMoves(players[currentPlayerIndex], board, BOARD_SIZE);
            } else {
                possibleMoves = []; // Clear for AI
            }
            renderGameBoard(); // Renders the board based on current state
            updateNextTurnButtonState();
        }

        // Updates the state of the "Next Turn" button
        function updateNextTurnButtonState() {
            if (gameOver) {
                nextTurnButton.classList.add('hidden');
                restartButton.classList.remove('hidden');
                gameStatusElement.textContent = `Gra zakonczona! Zwyciezca: ${winner}`;
            } else {
                const currentPlayer = players[currentPlayerIndex];
                if (currentPlayer.isAI) {
                    nextTurnButton.textContent = "Tura AI (poczekaj...)";
                    nextTurnButton.disabled = true;
                } else {
                    // Button is enabled if a normal move is selected OR if Shadow Donkey action is pending
                    nextTurnButton.textContent = selectedMove ? "Wykonaj Ruch" : (selectedPackageForRelocation ? "Wybierz puste pole" : "Wybierz Ruch");
                    nextTurnButton.disabled = (!selectedMove && !selectedPackageForRelocation);
                }
            }
        }

        // --- GAME FLOW ---

        // Handles a player's turn
        function nextTurn() {
            if (gameOver) return;

            // Deep copy of players and board to avoid direct state mutation issues before commit
            let updatedPlayers = JSON.parse(JSON.stringify(players));
            let currentGracz = updatedPlayers[currentPlayerIndex];
            let newBoard = JSON.parse(JSON.stringify(board));

            // Decrement Amulet active turns if active
            if (currentGracz.amuletActiveTurns > 0) {
                currentGracz.amuletActiveTurns -= 1;
                if (currentGracz.amuletActiveTurns === 0) {
                    gameLog.push(`  ${currentGracz.name}: Amulet przestal dzialac.`);
                }
            }
            // Decrement Shadow Donkey cooldown
            if (currentGracz.shadowCooldown > 0) {
                currentGracz.shadowCooldown -= 1;
            }

            // Reset extraMoveNextTurn before current player's action
            // This ensures any Oasis bonus from previous turn is cleared before calculating *this* turn's moves.
            // The Oasis bonus for *this* turn is added in handleTileAction and consumed by calculatePossibleMoves
            // when it's called to determine actual movement.
            currentGracz.extraMoveNextTurn = 0;


            // Check if player loses turn
            if (currentGracz.losesTurn > 0) {
                gameLog.push(`  ${currentGracz.name} traci ture z powodu pulapki/przeklenstwa. Pozostalo: ${currentGracz.losesTurn}.`);
                currentGracz.losesTurn -= 1;
                players = updatedPlayers; // Update players state
                renderPlayersInfo();
                updateGameLogUI();
                // Move to next player immediately
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                setTimeout(nextTurn, 500); // Small delay for AI turn or next human turn
                return;
            }

            // Human player logic
            if (!currentGracz.isAI) {
                if (!selectedMove && !selectedPackageForRelocation) { // If neither a move nor a package relocation is selected
                    gameLog.push(`  ${currentGracz.name}: Wybierz pole, na ktore chcesz sie ruszyc (lub pakunek jesli masz Czarnego Osiolka).`);
                    updateGameLogUI();
                    return;
                }
                // If a package was selected for relocation, but no empty tile clicked, it means the button was clicked
                // This shouldn't happen if the UI properly forces a tile click. But as a safeguard:
                if (selectedPackageForRelocation) {
                    gameLog.push(`  ${currentGracz.name}: Najpierw wybierz pakunek, a potem puste sąsiadujące pole.`);
                    updateGameLogUI();
                    selectedPackageForRelocation = null; // Clear state
                    renderGame();
                    return;
                }

                // Normal move execution
                if (selectedMove) {
                    // Update entire caravan's position
                    const oldCaravan = JSON.parse(JSON.stringify(currentGracz.caravan));
                    currentGracz.caravan[0] = { x: selectedMove.x, y: selectedMove.y, osiolek: oldCaravan[0].osiolek };
                    for (let i = 1; i < currentGracz.caravan.length; i++) {
                        currentGracz.caravan[i] = { ...oldCaravan[i - 1], osiolek: oldCaravan[i].osiolek };
                    }
                    gameLog.push(`  ${currentGracz.name} moved to (${selectedMove.x + 1}, ${selectedMove.y + 1}).`);
                    handleTileAction(currentGracz, newBoard, updatedPlayers);
                    selectedMove = null; // Reset selected move
                }
            } else {
                // AI logic
                aiMove(currentGracz, newBoard, updatedPlayers, BOARD_SIZE);
            }

            // Update global state
            board = newBoard;
            players = updatedPlayers;

            // Check for game over condition (e.g., all packages collected)
            const packagesOnBoard = board.flat().filter(tile => tile.type === 'package').length;
            if (packagesOnBoard === 0) {
                gameOver = true;
                const finalScores = players.map(p => ({ name: p.name, points: p.points }));
                const winningScore = Math.max(...finalScores.map(p => p.points));
                const winners = finalScores.filter(p => p.points === winningScore);
                winner = winners.length === 1 ? winners[0].name : "Remis";
                gameLog.push("--- KONIEC GRY! ---");
                gameLog.push(`Zwyciezca: ${winners.length === 1 ? winners[0].name : "Remis"} z ${winningScore} punktami!`);
                renderGame();
                updateGameLogUI();
                return;
            }

            // Move to next player
            currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
            renderGame();
            updateGameLogUI();

            // If next player is AI, trigger their turn after a short delay
            if (players[currentPlayerIndex].isAI) {
                setTimeout(nextTurn, 1000); // 1-second delay for AI turn
            }
        }

        // Handles tile clicks (for human player)
        function handleTileClick(x, y) {
            if (gameOver || players[currentPlayerIndex].isAI) return;

            const currentGracz = players[currentPlayerIndex];

            // --- Shadow Donkey (Czarny Osiolek) ability handling ---
            // If player has the ability and it's not on cooldown
            if (hasAbility(currentGracz, 'shadow') && currentGracz.shadowCooldown === 0) {
                if (selectedPackageForRelocation !== null) { // Player is in the process of relocating a package (second click)
                    const pakunekX = selectedPackageForRelocation.x;
                    const pakunekY = selectedPackageForRelocation.y;

                    // Check if new tile is adjacent and empty
                    if (calculateManhattanDistance(pakunekX, pakunekY, x, y) === 1 && board[x][y].type === 'empty') {
                        const pakunekBonus = board[pakunekX][pakunekY].bonus;
                        board[x][y] = Pole('package', pakunekBonus.name === 'Amulet' ? '✨' : pakunekBonus.name === 'Mapa' ? '🗺️' : '📦', pakunekBonus);
                        board[pakunekX][pakunekY] = Pole('empty', '.');
                        gameLog.push(`  ${currentGracz.name} uzyl Czarnego Osiolka! Przesunal pakunek z (${pakunekX + 1},${pakunekY + 1}) na (${x + 1},${y + 1}).`);
                        currentGracz.shadowCooldown = 3; // Set cooldown
                        selectedPackageForRelocation = null; // Reset package selection
                        selectedMove = null; // Clear normal move selection as well
                        updateGameLogUI();
                        renderGame(); // Re-render board and UI
                        return; // Action consumed, turn may continue or wait for next click on 'Wykonaj Ruch'
                    } else {
                        gameLog.push(`  Nieprawidlowe przesuniecie pakunku: wybierz sąsiadujące puste pole.`);
                        updateGameLogUI();
                        selectedPackageForRelocation = null; // Reset invalid selection
                        renderGame(); // Re-render to clear highlight
                        return;
                    }
                } else if (board[x][y].type === 'package') { // Player clicks a package to start relocation (first click)
                    selectedPackageForRelocation = { x, y };
                    selectedMove = null; // Clear any normal move selection
                    gameLog.push(`  ${currentGracz.name}: Wybrano pakunek na (${x + 1}, ${y + 1}). Kliknij sąsiednie puste pole, by go tam przesunąć.`);
                    updateGameLogUI();
                    renderGame(); // Re-render to show selected package
                    return;
                }
            }
            // --- End Shadow Donkey handling ---


            // Normal move logic - only if no package relocation is pending
            if (selectedPackageForRelocation === null) {
                const isPossible = possibleMoves.some(move => move.x === x && move.y === y);
                if (isPossible) {
                    selectedMove = { x, y };
                    renderGame(); // Re-render to show selected move
                } else {
                    gameLog.push(`  ${players[currentPlayerIndex].name}: Nie mozesz ruszyc sie na pole (${x + 1}, ${y + 1}).`);
                    updateGameLogUI();
                    selectedMove = null; // Clear any invalid selection
                    renderGame();
                }
            }
        }

        // --- EVENT LISTENERS ---
        nextTurnButton.addEventListener('click', nextTurn);
        restartButton.addEventListener('click', startGame);

        // --- INITIAL SETUP ---
        document.addEventListener('DOMContentLoaded', () => {
            startGame();
            renderLegend();
        });

    </script>
</body>
</html>
