<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karawana Burrito</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles, overriding Tailwind if necessary */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f7ede2; /* Lighter, sandy background */
        }
        .grid-item {
            width: 3rem;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.25rem; /* rounded-sm */
            text-align: center;
            font-size: 0.75rem;
            background-color: #fcf6e6; /* Very light sandy for empty tiles */
            transition: all 0.2s ease-in-out; /* Smooth transitions for hover effects */
        }
        .grid-item.highlight-move {
            background-color: #c0f7d5; /* Light green for possible moves */
            border-color: #22c55e;
            cursor: pointer;
        }
        .grid-item.highlight-move:hover {
            transform: scale(1.1);
        }
        /* Player-specific colors for leader icons */
        .player-1 { color: #f97316; } /* Orange */
        .player-2 { color: #2563eb; } /* Blue */
        .player-3 { color: #84cc16; } /* Lime Green */
        .player-4 { color: #ef4444; } /* Red */

        /* Responsive adjustments for larger screens */
        @media (min-width: 768px) {
            .grid-item {
                width: 4rem;
                height: 4rem;
                font-size: 0.875rem;
            }
        }
        @media (min-width: 1024px) {
            .grid-item {
                width: 5rem;
                height: 5rem;
                font-size: 1rem;
            }
        }

        /* Modal specific styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 2.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 15px 25px rgba(0, 0, 0, 0.4);
            text-align: center;
            max-width: 90%;
            width: 550px;
        }

        /* Toast notifications */
        #toast-container {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            z-index: 1001;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .toast {
            background-color: #2b2b2b;
            color: white;
            padding: 0.85rem 1.45rem;
            border-radius: 0.5rem;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2);
            opacity: 0;
            animation: fadeIn 0.3s forwards, fadeOut 3s forwards 2s;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(20px); }
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <div id="game-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 id="modal-title" class="text-3xl font-bold mb-4 text-amber-800">Karawana Burrito</h2>
            <p id="modal-message" class="text-lg text-gray-700 mb-6">Wyrusz w ekscytujƒÖcƒÖ podr√≥≈º przez pustyniƒô, zbierajƒÖc pakunki i rozbudowujƒÖc swojƒÖ karawanƒô osio≈Çk√≥w!</p>
            <button id="modal-button" class="px-8 py-4 bg-lime-600 text-white font-bold rounded-lg shadow-xl hover:bg-lime-700 transition-colors transform hover:scale-105">
                Rozpocznij Grƒô
            </button>
        </div>
    </div>

    <div id="game-container" class="flex flex-col lg:flex-row gap-8 w-full max-w-6xl hidden">
        <div class="lg:w-1/3 flex flex-col gap-4">
            <div class="bg-white rounded-lg shadow-xl p-4">
                <h2 class="text-xl font-semibold mb-3 text-amber-800">Gracze</h2>
                <div id="players-info">
                    </div>
            </div>

            <div class="bg-white rounded-lg shadow-xl p-4 flex-grow overflow-y-auto max-h-60 lg:max-h-[300px]">
                <h2 class="text-xl font-semibold mb-3 text-amber-800">Log Gry</h2>
                <div id="game-log" class="text-sm space-y-1">
                    </div>
            </div>
        </div>

        <div class="lg:w-2/3 flex flex-col gap-6">
            <div class="bg-white rounded-lg shadow-xl p-4">
                <h2 class="text-xl font-semibold mb-3 text-amber-800">Plansza</h2>
                <div id="game-board" class="grid gap-0.5" style="grid-template-columns: repeat(7, minmax(0, 1fr));">
                    </div>
            </div>

            <div class="bg-white rounded-lg shadow-xl p-4 flex flex-col sm:flex-row gap-4 justify-center items-center">
                <button id="next-turn-button" class="px-6 py-3 bg-orange-600 text-white font-bold rounded-lg shadow-lg hover:bg-orange-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105">
                    Wykonaj Ruch
                </button>
                <button id="use-bell-button" class="px-6 py-3 bg-teal-600 text-white font-bold rounded-lg shadow-lg hover:bg-teal-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105 hidden">
                    U≈ºyj Dzwonka üîî
                </button>
                <p id="game-status" class="text-lg font-semibold text-gray-700 mt-2"></p>
                <button id="restart-button" class="px-6 py-3 bg-red-600 text-white font-bold rounded-lg shadow-lg hover:bg-red-700 transition-colors transform hover:scale-105 hidden">
                    Zagraj Ponownie
                </button>
            </div>

            <div class="bg-white rounded-lg shadow-xl p-4">
                <h2 class="text-xl font-semibold mb-3 text-amber-800">Legenda</h2>
                <div id="legend-info" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 text-sm">
                    </div>
            </div>
        </div>
    </div>

    <div id="toast-container"></div>

    <script>
        // --- UI ELEMENTS ---
        const gameModal = document.getElementById('game-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalButton = document.getElementById('modal-button');
        const gameContainer = document.getElementById('game-container');
        const gameBoardElement = document.getElementById('game-board');
        const playersInfoElement = document.getElementById('players-info');
        const gameLogElement = document.getElementById('game-log');
        const nextTurnButton = document.getElementById('next-turn-button');
        const useBellButton = document.getElementById('use-bell-button');
        const gameStatusElement = document.getElementById('game-status');
        const restartButton = document.getElementById('restart-button');
        const legendInfoElement = document.getElementById('legend-info');
        const toastContainer = document.getElementById('toast-container');

        // --- GAME CONSTANTS ---
        const BOARD_SIZE = 7;
        const HUMAN_PLAYER_COUNT = 1; // You can change this to 2, 3, or 4 for more human players
        const AI_PLAYER_COUNT = 3;    // AI players will be added automatically up to 4 total players

        // --- GAME STATE ---
        let board;
        let players = [];
        let currentPlayerIndex;
        let gameLog = [];
        let possibleMoves = [];
        let moveInProgress = false;

        // --- GAME CLASSES AND OBJECTS ---
        const Pole = (type, symbol, bonus = null) => ({ type, symbol, bonus });
        const Osiolek = (type) => ({ type });
        const Gracz = (name, leaderSymbol, caravanSymbol, startX, startY, isAI = false) => ({
            name,
            leaderSymbol,
            caravanSymbol,
            caravan: [{ x: startX, y: startY, osiolek: Osiolek('zwykly') }],
            points: 0,
            packages: [],
            losesTurn: 0,
            extraMoveNextTurn: 0,
            donkeyAbilities: [],
            equipment: [],
            isAI,
            shadowCooldown: 0,
            amuletActiveTurns: 0,
            mapaBonusActive: false,
            bellCooldown: 0,
            prophetRevealedTile: null,
            targetPackage: null, // AI target
            targetDonkey: null, // AI target
        });

        // --- GAME LOGIC FUNCTIONS ---

        const initializeBoard = (size) => {
            const newBoard = Array.from({ length: size }, () => Array(size).fill(null).map(() => Pole('empty', '.')));

            // Packages (mixed types including new ones)
            newBoard[1][1] = Pole('package', 'üì¶', { points: 10, name: 'Wino' });
            newBoard[5][5] = Pole('package', 'üì¶', { points: 15, name: 'Przyprawy' });
            newBoard[0][0] = Pole('package', '‚ú®', { points: 5, name: 'Amulet' });
            newBoard[6][0] = Pole('package', 'üó∫Ô∏è', { points: 5, name: 'Mapa' });
            newBoard[2][2] = Pole('package', 'üì¶', { points: 8, name: 'Korale' });

            // Loose Donkeys
            newBoard[2][5] = Pole('donkey', 'üê¥');
            newBoard[3][4] = Pole('donkey', 'üê¥');

            // Food
            newBoard[2][3] = Pole('food', 'üçé');
            newBoard[5][3] = Pole('food', 'üçé');
            newBoard[6][5] = Pole('food', 'üçé');

            // Traps
            newBoard[3][3] = Pole('trap', '‚ò†Ô∏è', { turnsLost: 1 });
            newBoard[1][0] = Pole('trap', '‚ò†Ô∏è', { turnsLost: 1 });

            // Vineyards
            newBoard[0][2] = Pole('vineyard', 'üçá');
            newBoard[6][4] = Pole('vineyard', 'üçá');

            // Mountain Shortcuts (shortcut to package at (1,1))
            newBoard[3][0] = Pole('mountain_shortcut', 'üèîÔ∏è', { targetX: 1, targetY: 1 });

            // Cacti
            newBoard[4][1] = Pole('cactus', 'üåµ');
            newBoard[0][1] = Pole('cactus', 'üåµ');
            newBoard[5][4] = Pole('cactus', 'üåµ');

            // River and Bridges
            newBoard[3][1] = Pole('river', 'üåä');
            newBoard[4][2] = Pole('bridge', 'üåâ');
            newBoard[5][2] = Pole('river', 'üåä');
            newBoard[2][6] = Pole('river', 'üåä');

            // Bazaar
            newBoard[0][6] = Pole('bazar', 'üí∞');

            // Fences
            newBoard[4][4] = Pole('fence', 'üöß');
            newBoard[1][4] = Pole('fence', 'üöß');

            // Bandits
            newBoard[1][3] = Pole('bandits', 'ü§†');
            newBoard[5][1] = Pole('bandits', 'ü§†');

            // Well
            newBoard[4][6] = Pole('well', 'üíß');
            newBoard[1][6] = Pole('well', 'üíß');

            // Oasis
            newBoard[6][3] = Pole('oasis', 'üå¥');
            newBoard[0][3] = Pole('oasis', 'üå¥');

            // Equipment (Dzwonek i Sakwa)
            newBoard[3][6] = Pole('equipment', 'üîî', { equipmentType: 'dzwonek' });
            newBoard[6][2] = Pole('equipment', 'üíº', { equipmentType: 'sakwa' });

            // Special Donkeys (unique)
            newBoard[1][5] = Pole('special_donkey', '‚ö™', { donkeyType: 'guide', name: 'Bialy Osiolek' });
            newBoard[4][0] = Pole('special_donkey', '‚ö´', { donkeyType: 'shadow', name: 'Czarny Osiolek' });
            newBoard[6][1] = Pole('special_donkey', 'üü´', { donkeyType: 'sturdy', name: 'Brazowy Osiolek' });
            newBoard[0][4] = Pole('special_donkey', 'üåü', { donkeyType: 'prorok', name: 'Zloty Osiolek (Prorok)' });
            newBoard[5][0] = Pole('special_donkey', 'üéí', { donkeyType: 'wloczega', name: 'Zielony Osiolek (Wloczega)' });

            return newBoard;
        };

        const legend = [
            { symbol: 'üì¶', name: 'Pakunek', desc: 'Zbierz, aby zdobyƒá punkty.' },
            { symbol: '‚ú®', name: 'Amulet', desc: 'Chroni przed pu≈Çapkami i bandytami na 3 tury.' },
            { symbol: 'üó∫Ô∏è', name: 'Mapa', desc: 'Daje sta≈Çy, dodatkowy ruch (+1).' },
            { symbol: 'üîî', name: 'Dzwonek', desc: 'Sprzƒôt, pozwala ukra≈õƒá pakunek innemu graczowi.' },
            { symbol: 'üíº', name: 'Sakwa', desc: 'Sprzƒôt, daje sta≈Çy, dodatkowy ruch (+1).' },
            { symbol: 'üê¥', name: 'Luzny Osio≈Çek', desc: 'Do≈ÇƒÖcza do karawany, zwiƒôkszajƒÖc jej d≈Çugo≈õƒá.' },
            { symbol: '‚ö™', name: 'Bia≈Çy Osio≈Çek', desc: 'Przewodnik, teleportuje na losowe pole.' },
            { symbol: '‚ö´', name: 'Czarny Osio≈Çek', desc: 'Cie≈Ñ, pozwala na kopiowanie ruch√≥w innego gracza.' },
            { symbol: 'üü´', name: 'BrƒÖzowy Osio≈Çek', desc: 'Twardziel, uodparnia na pu≈Çapki i bandyt√≥w.' },
            { symbol: 'üåü', name: 'Z≈Çoty Osio≈Çek', desc: 'Prorok, ujawnia pobliskie interesujƒÖce pola.' },
            { symbol: 'üéí', name: 'Zielony Osio≈Çek', desc: 'W≈Ç√≥czƒôga, ignoruje spowalniajƒÖce kaktusy.' },
            { symbol: 'üçé', name: 'Jedzenie', desc: 'Karawana ro≈õnie o 1 losowego osio≈Çka.' },
            { symbol: '‚ò†Ô∏è', name: 'Pu≈Çapka', desc: 'Tracisz 1 turƒô (chyba ≈ºe masz Amulet lub Twardziela).' },
            { symbol: 'ü§†', name: 'Bandyci', desc: 'Tracisz 1 pakunek lub osio≈Çka (chyba ≈ºe masz Amulet lub Twardziela).' },
            { symbol: 'üçá', name: 'Winnica', desc: 'Zyskujesz +1 ruch w nastƒôpnej turze.' },
            { symbol: 'üèîÔ∏è', name: 'Skr√≥t G√≥rski', desc: 'Teleportuje do innej lokacji na planszy.' },
            { symbol: 'üí∞', name: 'Bazar', desc: 'Sprzedaj 1 pakunek za 5 punkt√≥w.' },
            { symbol: 'üåµ', name: 'Kaktus', desc: 'Kosztuje dodatkowy ruch (chyba ≈ºe masz W≈Ç√≥czƒôgƒô).' },
            { symbol: 'üåä', name: 'Rzeka', desc: 'Pole nieprzechodnie, tracisz turƒô.' },
            { symbol: 'üåâ', name: 'Most', desc: 'Mo≈ºna przechodziƒá przez rzekƒô.' },
            { symbol: 'üöß', name: 'P≈Çot', desc: 'Pole nieprzechodnie, tracisz turƒô.' },
            { symbol: 'üíß', name: 'Studnia', desc: 'Losowy bonus (nowy osio≈Çek, +1 ruch) lub kara (-1 tura).' },
            { symbol: 'üå¥', name: 'Oaza', desc: 'Zyskujesz +1 ruch w obecnej turze.' },
        ];

        const calculateManhattanDistance = (x1, y1, x2, y2) => Math.abs(x1 - x2) + Math.abs(y1 - y2);
        const hasAbility = (player, abilityType) => player.donkeyAbilities.includes(abilityType);
        const hasEquipment = (player, equipmentType) => player.equipment.includes(equipmentType);

        function showToast(message) {
            const toastDiv = document.createElement('div');
            toastDiv.classList.add('toast');
            toastDiv.textContent = message;
            toastContainer.appendChild(toastDiv);
            setTimeout(() => { toastDiv.remove(); }, 3000);
        }

        const handleTileAction = (player, board, playersList) => {
            const { x, y } = player.caravan[0];
            const tile = board[x][y];
            let newLog = [];

            if (tile.type === 'empty') return;

            newLog.push(`[${player.name}] wszed≈Ç na pole: ${tile.type} (${tile.symbol})`);
            showToast(`${player.name} wszed≈Ç na pole: ${tile.type}`);

            switch (tile.type) {
                case 'package':
                    player.points += tile.bonus.points;
                    player.packages.push(tile.bonus.name);
                    newLog.push(`-> ${player.name} zebra≈Ç pakunek '${tile.bonus.name}'! Zdoby≈Ç ${tile.bonus.points} punkt√≥w.`);
                    showToast(`${player.name} zebra≈Ç pakunek: ${tile.bonus.name}!`);

                    if (tile.bonus.name === 'Amulet') {
                        player.equipment.push('amulet');
                        player.amuletActiveTurns = 3;
                        newLog.push(`-> ${player.name} aktywowa≈Ç Amulet! Chroniony na 3 tury.`);
                        showToast(`${player.name}: Amulet aktywny!`);
                    } else if (tile.bonus.name === 'Mapa') {
                        player.equipment.push('mapa');
                        player.mapaBonusActive = true;
                        newLog.push(`-> ${player.name} znalaz≈Ç Mapƒô! Zyskuje +1 sta≈Çy ruch.`);
                        showToast(`${player.name}: Znalaz≈Ç Mapƒô!`);
                    }
                    board[x][y] = Pole('empty', '.');
                    break;
                case 'donkey':
                    newLog.push(`-> ${player.name} znalaz≈Ç lu≈∫nego osio≈Çka! Do≈ÇƒÖcza do karawany.`);
                    showToast(`${player.name}: Znalaz≈Ç lu≈∫nego osio≈Çka!`);
                    player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek('zwykly') });
                    board[x][y] = Pole('empty', '.');
                    break;
                case 'special_donkey':
                    newLog.push(`-> ${player.name} znalaz≈Ç ${tile.bonus.name}! Do≈ÇƒÖcza do karawany.`);
                    showToast(`${player.name}: Znalaz≈Ç specjalnego osio≈Çka: ${tile.bonus.name}!`);
                    player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek(tile.bonus.donkeyType) });
                    if (!player.donkeyAbilities.includes(tile.bonus.donkeyType)) {
                        player.donkeyAbilities.push(tile.bonus.donkeyType);
                        newLog.push(`-> ${player.name} zdobywa umiejƒôtno≈õƒá: ${tile.bonus.donkeyType.charAt(0).toUpperCase() + tile.bonus.donkeyType.slice(1)}!`);
                        showToast(`${player.name} zdobywa umiejƒôtno≈õƒá: ${tile.bonus.donkeyType}!`);
                    }
                    board[x][y] = Pole('empty', '.');
                    break;
                case 'equipment':
                    player.equipment.push(tile.bonus.equipmentType);
                    newLog.push(`-> ${player.name} znalaz≈Ç sprzƒôt: ${tile.bonus.equipmentType}!`);
                    showToast(`${player.name}: Znalaz≈Ç sprzƒôt: ${tile.bonus.equipmentType}!`);
                    board[x][y] = Pole('empty', '.');
                    break;
                case 'food':
                    newLog.push(`-> ${player.name} znalaz≈Ç jedzenie! Karawana siƒô rozmna≈ºa.`);
                    showToast(`${player.name}: Jedzenie! Karawana ro≈õnie!`);
                    const donkeyTypes = ['zwykly', 'sturdy', 'thief', 'prophet', 'wanderer', 'guide'];
                    const newDonkeyType = donkeyTypes[Math.floor(Math.random() * donkeyTypes.length)];
                    player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek(newDonkeyType) });
                    if (newDonkeyType !== 'zwykly') {
                        if (!player.donkeyAbilities.includes(newDonkeyType)) {
                            player.donkeyAbilities.push(newDonkeyType);
                            newLog.push(`-> Nowy osio≈Çek do≈ÇƒÖczony! Typ: ${newDonkeyType}!`);
                            showToast(`Nowy osio≈Çek: ${newDonkeyType}!`);
                        } else {
                            newLog.push(`-> Nowy osio≈Çek typu ${newDonkeyType} do≈ÇƒÖczony! (Umiejƒôtno≈õƒá ju≈º jest).`);
                        }
                    } else {
                        newLog.push(`-> Nowy osio≈Çek do≈ÇƒÖczony! Typ: Zwyk≈Çy.`);
                    }
                    board[x][y] = Pole('empty', '.');
                    break;
                case 'trap':
                    if (player.amuletActiveTurns > 0 || hasAbility(player, 'sturdy')) {
                        newLog.push(`-> ${player.name} wpad≈Ç w pu≈Çapkƒô, ale zosta≈Ç ochroniony!`);
                        showToast(`${player.name}: Ochrona przed pu≈ÇapkƒÖ!`);
                    } else {
                        player.losesTurn += 1;
                        newLog.push(`-> ${player.name} wpad≈Ç w pu≈Çapkƒô! Traci 1 turƒô.`);
                        showToast(`${player.name}: Wpad≈Ç w pu≈Çapkƒô! Traci turƒô!`);
                    }
                    break;
                case 'vineyard':
                    player.extraMoveNextTurn += 1;
                    newLog.push(`-> ${player.name} znalaz≈Ç winnicƒô! Zyskuje +1 ruch w nastƒôpnej turze.`);
                    showToast(`${player.name}: Winnica! +1 ruch w nast. turze!`);
                    break;
                case 'mountain_shortcut':
                    const { targetX, targetY } = tile.bonus;
                    newLog.push(`-> ${player.name} u≈ºy≈Ç skr√≥tu! Przeni√≥s≈Ç siƒô na pole (${targetX + 1}, ${targetY + 1}).`);
                    showToast(`${player.name}: Skr√≥t! Teleport do (${targetX + 1}, ${targetY + 1})!`);
                    player.caravan[0] = { x: targetX, y: targetY, osiolek: player.caravan[0].osiolek };
                    for (let i = 1; i < player.caravan.length; i++) {
                        player.caravan[i] = {
                            x: targetX, y: targetY, osiolek: player.caravan[i].osiolek
                        };
                    }
                    break;
                case 'bazar':
                    newLog.push(`-> ${player.name} jest na Bazarze. Mo≈ºe sprzedaƒá pakunek.`);
                    showToast(`${player.name}: Bazar! Sprzedaj pakunki!`);
                    if (player.packages.length > 0) {
                        const soldPackage = player.packages.pop();
                        player.points += 5;
                        newLog.push(`-> ${player.name} sprzeda≈Ç '${soldPackage}' za 5 punkt√≥w.`);
                        showToast(`${player.name}: Sprzeda≈Ç '${soldPackage}'!`);
                    } else {
                        newLog.push("-> Nie masz pakunk√≥w do sprzedania.");
                        showToast("Brak pakunk√≥w do sprzedania.");
                    }
                    break;
                case 'cactus':
                    newLog.push(`-> ${player.name} wszed≈Ç na kaktusa! Ruch w nastƒôpnej turze mo≈ºe byƒá spowolniony.`);
                    showToast(`${player.name}: Kaktus!`);
                    break;
                case 'river':
                case 'fence':
                    newLog.push(`-> ${player.name} wszed≈Ç na przeszkodƒô! Traci 1 turƒô.`);
                    showToast(`${player.name}: Przeszkoda! Traci turƒô!`);
                    player.losesTurn += 1;
                    break;
                case 'bandits':
                    if (player.amuletActiveTurns > 0 || hasAbility(player, 'sturdy')) {
                        newLog.push(`-> ${player.name} spotka≈Ç Bandyt√≥w, ale zosta≈Ç ochroniony!`);
                        showToast(`${player.name}: Ochrona przed Bandytami!`);
                    } else {
                        const lostItemType = Math.random() < 0.5 ? 'package' : 'donkey';
                        if (lostItemType === 'package' && player.packages.length > 0) {
                            const lostPackage = player.packages.pop();
                            newLog.push(`-> ${player.name} spotka≈Ç Bandyt√≥w! Straci≈Ç pakunek: '${lostPackage}'.`);
                            showToast(`${player.name}: Bandyci! Straci≈Ç '${lostPackage}'!`);
                        } else if (lostItemType === 'donkey' && player.caravan.length > 1) {
                            const lostDonkey = player.caravan.pop();
                            if (lostDonkey.osiolek.type !== 'zwykly') {
                                player.donkeyAbilities = player.donkeyAbilities.filter(ability => ability !== lostDonkey.osiolek.type);
                            }
                            newLog.push(`-> ${player.name} spotka≈Ç Bandyt√≥w! Straci≈Ç osio≈Çka.`);
                            showToast(`${player.name}: Bandyci! Straci≈Ç osio≈Çka!`);
                        } else {
                            newLog.push(`-> ${player.name} spotka≈Ç Bandyt√≥w, ale nic nie straci≈Ç.`);
                            showToast(`${player.name}: Bandyci... ale nic nie straci≈Ç!`);
                        }
                    }
                    break;
                case 'well':
                    const wellOutcome = Math.random();
                    if (wellOutcome < 0.4) {
                        newLog.push(`-> ${player.name} znalaz≈Ç Studniƒô! Zyskuje nowego osio≈Çka!`);
                        showToast(`${player.name}: Studnia! Nowy osio≈Çek!`);
                        const donkeyTypes = ['zwykly', 'sturdy', 'thief'];
                        const newDonkeyType = donkeyTypes[Math.floor(Math.random() * donkeyTypes.length)];
                        player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek(newDonkeyType) });
                        if (newDonkeyType !== 'zwykly' && !player.donkeyAbilities.includes(newDonkeyType)) {
                            player.donkeyAbilities.push(newDonkeyType);
                        }
                    } else if (wellOutcome < 0.7) {
                        player.extraMoveNextTurn += 1;
                        newLog.push(`-> ${player.name} znalaz≈Ç Studniƒô! Zyskuje +1 ruch w nastƒôpnej turze.`);
                        showToast(`${player.name}: Studnia! +1 ruch w nast. turze!`);
                    } else {
                        newLog.push(`-> ${player.name} znalaz≈Ç Studniƒô! Niestety, traci 1 turƒô.`);
                        showToast(`${player.name}: Studnia... Traci turƒô!`);
                        player.losesTurn += 1;
                    }
                    break;
                case 'oasis':
                    newLog.push(`-> ${player.name} wszed≈Ç na Oazƒô! Zyskuje +1 ruch w tej turze!`);
                    showToast(`${player.name}: Oaza! +1 ruch w tej turze!`);
                    player.extraMoveNextTurn += 1;
                    break;
            }

            if (hasAbility(player, 'thief')) {
                if (Math.random() < 0.2) {
                    const otherPlayersWithPackages = playersList.filter(p => p !== player && p.packages.length > 0);
                    if (otherPlayersWithPackages.length > 0) {
                        const targetPlayer = otherPlayersWithPackages[Math.floor(Math.random() * otherPlayersWithPackages.length)];
                        const stolenPackage = targetPlayer.packages.pop();
                        player.packages.push(stolenPackage);
                        player.points += 5;
                        newLog.push(`-> Z≈ÅODZIEJ! ${player.name} ukrad≈Ç '${stolenPackage}' od ${targetPlayer.name}! Zyska≈Ç 5 punkt√≥w.`);
                        showToast(`${player.name}: Ukrad≈Ç '${stolenPackage}' od ${targetPlayer.name}!`);
                    }
                }
            }
            gameLog.push(...newLog);
            updateGameLogUI();
        };

        const findClosestInterestingTile = (player, board, size, maxDistance = 3) => {
            const { x: currentX, y: currentY } = player.caravan[0];
            let closestTile = null;
            let minDistance = Infinity;

            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const tile = board[r][c];
                    const distance = calculateManhattanDistance(currentX, currentY, r, c);
                    if (distance > 0 && distance <= maxDistance) {
                        if (['package', 'food', 'donkey', 'special_donkey', 'equipment'].includes(tile.type)) {
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestTile = { x: r, y: c, type: tile.type, symbol: tile.symbol };
                            }
                        }
                    }
                }
            }
            return closestTile;
        };

        const calculatePossibleMoves = (player, board, size) => {
            const { x: currentX, y: currentY } = player.caravan[0];
            const possibleMoves = [];
            let baseMovement = 2;

            baseMovement += player.extraMoveNextTurn;
            if (hasEquipment(player, 'sakwa')) baseMovement += 1;
            if (player.mapaBonusActive) baseMovement += 1;

            const actualMovement = Math.max(1, baseMovement);
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            for (const [dx, dy] of directions) {
                for (let step = 1; step <= actualMovement; step++) {
                    const nextX = currentX + dx * step;
                    const nextY = currentY + dy * step;

                    if (nextX >= 0 && nextX < size && nextY >= 0 && nextY < size) {
                        const tile = board[nextX][nextY];
                        let cost = step;

                        if (tile.type === 'cactus' && !hasAbility(player, 'wanderer')) {
                            cost += 1;
                        }

                        let blockedPath = false;
                        for (let i = 1; i < step; i++) {
                            const intermediateTile = board[currentX + dx * i][currentY + dy * i];
                            if (intermediateTile.type === 'fence' || (intermediateTile.type === 'river' && intermediateTile.type !== 'bridge')) {
                                blockedPath = true;
                                break;
                            }
                        }
                        if (blockedPath) continue;

                        if (cost <= actualMovement) {
                            possibleMoves.push({ x: nextX, y: nextY, cost: cost });
                        }
                    }
                }
            }
            return possibleMoves;
        };

        const aiMove = (player, board, playersList, size) => {
            let currentTurnPossibleMoves = calculatePossibleMoves(player, board, size);

            // AI Logic for using the Bell
            if (hasEquipment(player, 'dzwonek') && player.bellCooldown === 0) {
                const packagesToSteal = playersList.filter(p => p !== player && p.packages.length > 0).length;
                if (packagesToSteal > 0) {
                    player.bellCooldown = 3;
                    gameLog.push(`[${player.name} (AI)] u≈ºywa Dzwonka, aby ukra≈õƒá pakunek!`);
                    showToast(`${player.name} (AI) u≈ºywa Dzwonka!`);
                    const targetPlayer = playersList.find(p => p !== player && p.packages.length > 0);
                    if (targetPlayer) {
                        const stolenPackage = targetPlayer.packages.pop();
                        player.packages.push(stolenPackage);
                        player.points += 5;
                        gameLog.push(`-> ${player.name} (AI) ukrad≈Ç '${stolenPackage}' od ${targetPlayer.name}.`);
                        showToast(`${player.name} (AI) ukrad≈Ç '${stolenPackage}'!`);
                    }
                }
            }

            // AI Logic for Prophet
            if (hasAbility(player, 'prophet') && player.prophetRevealedTile === null) {
                player.prophetRevealedTile = findClosestInterestingTile(player, board, size);
                if (player.prophetRevealedTile) {
                    gameLog.push(`[${player.name} (AI)] (Prorok) wyczuwa co≈õ na polu (${player.prophetRevealedTile.x + 1}, ${player.prophetRevealedTile.y + 1}).`);
                }
            }

            // Find a target to move towards
            let bestMove = null;
            let bestScore = -Infinity;

            const targets = [];
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const tile = board[r][c];
                    if (['package', 'special_donkey', 'donkey', 'food', 'equipment'].includes(tile.type)) {
                        targets.push({ x: r, y: c, type: tile.type, score: calculateItemScore(tile.type) });
                    }
                }
            }

            // Simple scoring system for AI decision making
            function calculateItemScore(type) {
                switch (type) {
                    case 'package': return 10;
                    case 'special_donkey': return 8;
                    case 'donkey': return 5;
                    case 'equipment': return 5;
                    case 'food': return 3;
                    default: return 0;
                }
            }

            for (const move of currentTurnPossibleMoves) {
                const moveTile = board[move.x][move.y];
                let score = calculateItemScore(moveTile.type);

                // Additional scoring based on proximity to other targets
                const distanceToClosestTarget = Math.min(...targets.map(target => calculateManhattanDistance(move.x, move.y, target.x, target.y)));
                score += (20 / (distanceToClosestTarget + 1)); // Prefer moves closer to other items

                // Avoid bad tiles
                if (['trap', 'bandits', 'river', 'fence'].includes(moveTile.type) && !hasAbility(player, 'sturdy') && player.amuletActiveTurns === 0) {
                    score -= 50; // Heavily penalize bad moves
                }
                if (moveTile.type === 'cactus' && !hasAbility(player, 'wanderer')) {
                    score -= 5;
                }

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }

            // If no "good" move, just take the first possible move
            if (!bestMove && currentTurnPossibleMoves.length > 0) {
                bestMove = currentTurnPossibleMoves[0];
            }

            if (bestMove) {
                movePlayer(player, bestMove.x, bestMove.y);
            }
        };

        const movePlayer = (player, newX, newY) => {
            const oldX = player.caravan[0].x;
            const oldY = player.caravan[0].y;

            const newCaravan = [{ x: newX, y: newY, osiolek: player.caravan[0].osiolek }];
            for (let i = 1; i < player.caravan.length; i++) {
                newCaravan.push({ x: player.caravan[i - 1].x, y: player.caravan[i - 1].y, osiolek: player.caravan[i].osiolek });
            }
            player.caravan = newCaravan;
            handleTileAction(player, board, players);
        };

        const updateGameUI = () => {
            gameBoardElement.innerHTML = '';
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    const tileDiv = document.createElement('div');
                    tileDiv.classList.add('grid-item');
                    tileDiv.dataset.x = i;
                    tileDiv.dataset.y = j;
                    tileDiv.textContent = board[i][j].symbol;

                    // Add click handler for human player
                    if (!players[currentPlayerIndex].isAI && possibleMoves.some(m => m.x === i && m.y === j)) {
                        tileDiv.classList.add('highlight-move');
                        tileDiv.addEventListener('click', () => {
                            if (!moveInProgress) {
                                moveInProgress = true;
                                movePlayer(players[currentPlayerIndex], i, j);
                                setTimeout(() => {
                                    endTurn();
                                    moveInProgress = false;
                                }, 500); // Small delay for visual feedback
                            }
                        });
                    }
                    gameBoardElement.appendChild(tileDiv);
                }
            }

            // Draw players on top of the board
            players.forEach(player => {
                player.caravan.forEach((segment, index) => {
                    const tileDiv = gameBoardElement.querySelector(`[data-x="${segment.x}"][data-y="${segment.y}"]`);
                    if (tileDiv) {
                        const playerSymbol = index === 0 ? player.leaderSymbol : player.caravanSymbol;
                        const symbolSpan = document.createElement('span');
                        symbolSpan.textContent = playerSymbol;
                        symbolSpan.classList.add(index === 0 ? `player-${players.indexOf(player) + 1}` : '');
                        tileDiv.innerHTML = ''; // Clear existing content
                        tileDiv.appendChild(symbolSpan);
                    }
                });
            });

            updatePlayersInfoUI();
        };

        const updatePlayersInfoUI = () => {
            playersInfoElement.innerHTML = '';
            players.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                const playerColorClass = `player-${index + 1}`;
                const playerPackages = player.packages.join(', ') || 'Brak';
                const playerAbilities = player.donkeyAbilities.join(', ') || 'Brak';
                const playerEquipment = player.equipment.join(', ') || 'Brak';

                playerDiv.innerHTML = `
                    <div class="flex items-center gap-2 mb-1">
                        <span class="text-2xl ${playerColorClass}">${player.leaderSymbol}</span>
                        <p class="font-bold text-gray-800">${player.name}</p>
                        ${currentPlayerIndex === index ? ' <span class="text-xs font-semibold text-lime-600">(Twoja Tura)</span>' : ''}
                        ${player.isAI ? ' <span class="text-xs font-semibold text-sky-600">(AI)</span>' : ''}
                    </div>
                    <p class="text-sm text-gray-600">Punkty: <span class="font-semibold text-green-700">${player.points}</span></p>
                    <p class="text-sm text-gray-600">Karawana: <span class="font-semibold">${player.caravan.length}</span> osio≈Çk√≥w</p>
                    <p class="text-sm text-gray-600">Pakunki: <span class="font-semibold">${player.packages.length}</span> (${playerPackages})</p>
                    <p class="text-sm text-gray-600">Umiejƒôtno≈õci: <span class="font-semibold">${playerAbilities}</span></p>
                    <p class="text-sm text-gray-600">Sprzƒôt: <span class="font-semibold">${playerEquipment}</span></p>
                    ${player.losesTurn > 0 ? `<p class="text-sm text-red-600 font-semibold mt-1">Traci tury: ${player.losesTurn}</p>` : ''}
                    ${player.amuletActiveTurns > 0 ? `<p class="text-sm text-blue-600 font-semibold mt-1">Amulet: ${player.amuletActiveTurns} tury</p>` : ''}
                `;
                playersInfoElement.appendChild(playerDiv);
            });
        };

        const updateGameLogUI = () => {
            gameLogElement.innerHTML = '';
            gameLog.slice(-10).reverse().forEach(log => { // Show last 10 entries
                const logEntry = document.createElement('p');
                logEntry.textContent = log;
                gameLogElement.appendChild(logEntry);
            });
            gameLogElement.scrollTop = gameLogElement.scrollHeight;
        };

        const updateLegendUI = () => {
            legendInfoElement.innerHTML = '';
            legend.forEach(item => {
                const legendItem = document.createElement('div');
                legendItem.classList.add('flex', 'items-center', 'gap-2');
                legendItem.innerHTML = `<span class="text-lg">${item.symbol}</span><p class="font-semibold">${item.name}</p>`;
                legendInfoElement.appendChild(legendItem);
            });
        };

        const updateTurnUI = () => {
            const currentPlayer = players[currentPlayerIndex];
            gameStatusElement.textContent = `Tura: ${currentPlayer.name}`;

            if (currentPlayer.isAI) {
                nextTurnButton.classList.add('hidden');
                useBellButton.classList.add('hidden');
                setTimeout(aiTurn, 1000); // AI moves automatically
            } else {
                nextTurnButton.classList.remove('hidden');
                nextTurnButton.textContent = `Wykonaj Ruch ( ${players[currentPlayerIndex].extraMoveNextTurn + 2 + (hasEquipment(currentPlayer, 'sakwa') ? 1 : 0) + (currentPlayer.mapaBonusActive ? 1 : 0)} ruchy)`;
                if (hasEquipment(currentPlayer, 'dzwonek') && currentPlayer.bellCooldown === 0) {
                    useBellButton.classList.remove('hidden');
                } else {
                    useBellButton.classList.add('hidden');
                }

                if (currentPlayer.losesTurn > 0) {
                    nextTurnButton.disabled = true;
                    nextTurnButton.textContent = `Pauza (${currentPlayer.losesTurn} tury)`;
                } else {
                    nextTurnButton.disabled = false;
                }
            }
        };

        const startNewGame = () => {
            gameModal.classList.add('hidden');
            gameContainer.classList.remove('hidden');

            board = initializeBoard(BOARD_SIZE);
            players = [];
            players.push(Gracz('Gracz', 'üö∂', 'üö∂', 0, 0, false));
            
            for (let i = 0; i < AI_PLAYER_COUNT; i++) {
                const aiNames = ['AI-1', 'AI-2', 'AI-3'];
                const aiSymbols = ['ü§†', 'ü§ñ', 'üëæ'];
                players.push(Gracz(aiNames[i], aiSymbols[i], aiSymbols[i], 6, 6, true));
            }
            
            players = shuffleArray(players);
            currentPlayerIndex = 0;
            gameLog = ['Nowa gra rozpoczƒôta!'];
            updateLegendUI();
            startTurn();
        };

        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };
        
        const startTurn = () => {
            const currentPlayer = players[currentPlayerIndex];
            gameLog.push(`\n--- Tura ${currentPlayer.name} ---`);

            if (currentPlayer.losesTurn > 0) {
                currentPlayer.losesTurn--;
                gameLog.push(`-> ${currentPlayer.name} traci turƒô. Pozosta≈Ço: ${currentPlayer.losesTurn}`);
                setTimeout(endTurn, 1000);
            } else {
                if (currentPlayer.amuletActiveTurns > 0) currentPlayer.amuletActiveTurns--;
                if (currentPlayer.bellCooldown > 0) currentPlayer.bellCooldown--;
                
                // Prophet ability logic
                if (hasAbility(currentPlayer, 'prophet')) {
                    const revealedTile = findClosestInterestingTile(currentPlayer, board, BOARD_SIZE);
                    if (revealedTile) {
                        gameLog.push(`-> ${currentPlayer.name} (Prorok) wyczuwa co≈õ na polu (${revealedTile.x + 1}, ${revealedTile.y + 1}).`);
                    } else {
                        gameLog.push(`-> ${currentPlayer.name} (Prorok) nic nie wyczuwa w pobli≈ºu.`);
                    }
                }
                
                possibleMoves = calculatePossibleMoves(currentPlayer, board, BOARD_SIZE);
                updateGameUI();
                updateTurnUI();
            }
            updateGameLogUI();
        };

        const endTurn = () => {
            players[currentPlayerIndex].extraMoveNextTurn = 0;
            currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
            startTurn();
        };

        const aiTurn = () => {
            const currentPlayer = players[currentPlayerIndex];
            gameStatusElement.textContent = `Tura: ${currentPlayer.name} (AI)`;
            aiMove(currentPlayer, board, players, BOARD_SIZE);
            updateGameUI();
            setTimeout(endTurn, 1500); // AI turn takes 1.5s for better flow
        };

        const checkWinCondition = () => {
            const winningPlayer = players.find(p => p.points >= 50 && p.caravan.length >= 5);
            if (winningPlayer) {
                gameModal.classList.remove('hidden');
                modalTitle.textContent = `Koniec Gry! Zwyciƒôzca: ${winningPlayer.name}! üéâ`;
                modalMessage.textContent = `Karawana ${winningPlayer.name} zdoby≈Ça co najmniej 50 punkt√≥w i ma 5 osio≈Çk√≥w. Gratulacje!`;
                modalButton.textContent = 'Zagraj Ponownie';
                restartButton.classList.remove('hidden');
                nextTurnButton.classList.add('hidden');
                useBellButton.classList.add('hidden');
            }
        };

        // --- EVENT LISTENERS ---
        modalButton.addEventListener('click', startNewGame);
        restartButton.addEventListener('click', startNewGame);

        nextTurnButton.addEventListener('click', () => {
            gameLog.push(`[${players[currentPlayerIndex].name}] wykona≈Ç ruch.`);
            endTurn();
        });

        useBellButton.addEventListener('click', () => {
            const player = players[currentPlayerIndex];
            if (hasEquipment(player, 'dzwonek') && player.bellCooldown === 0) {
                const otherPlayersWithPackages = players.filter(p => p !== player && p.packages.length > 0);
                if (otherPlayersWithPackages.length > 0) {
                    const targetPlayer = otherPlayersWithPackages[Math.floor(Math.random() * otherPlayersWithPackages.length)];
                    const stolenPackage = targetPlayer.packages.pop();
                    player.packages.push(stolenPackage);
                    player.points += 5;
                    player.bellCooldown = 3;
                    gameLog.push(`[${player.name}] u≈ºywa Dzwonka i kradnie '${stolenPackage}' od ${targetPlayer.name}! Zyska≈Ç 5 punkt√≥w.`);
                    showToast(`U≈ºy≈Çe≈õ Dzwonka! Ukrad≈Çe≈õ pakunek od ${targetPlayer.name}!`);
                    updateGameUI();
                    updateTurnUI();
                } else {
                    showToast('Nie ma od kogo kra≈õƒá! Brak pakunk√≥w u innych graczy.');
                    gameLog.push(`[${player.name}] chcia≈Ç u≈ºyƒá Dzwonka, ale nikt nie ma pakunk√≥w.`);
                }
            }
        });

        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            gameModal.classList.remove('hidden');
            updateLegendUI();
        });
    </script>
</body>
</html>
