<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karawana Burrito</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game, if needed, overriding Tailwind */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f7ede2; /* Lighter, sandy background for the whole page */
        }
        /* Specific styling for the game board grid items for better visuals */
        .grid-item {
            width: 3rem; /* Fixed width for tiles */
            height: 3rem; /* Fixed height for tiles */
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.25rem; /* rounded-sm */
            text-align: center;
            font-size: 0.75rem; /* text-xs */
            background-color: #fcf6e6; /* Very light sandy for empty tiles */
        }

        /* Responsive adjustments for larger screens if necessary, overriding fixed size */
        @media (min-width: 768px) {
            .grid-item {
                width: 4rem; /* Larger tiles on medium screens */
                height: 4rem;
                font-size: 0.875rem; /* text-sm */
            }
        }
        @media (min-width: 1024px) {
            .grid-item {
                width: 5rem; /* Even larger tiles on large screens */
                height: 5rem;
                font-size: 1rem; /* text-base */
            }
        }

        /* Modal specific styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 2.5rem; /* Slightly more padding */
            border-radius: 0.75rem; /* More rounded */
            box-shadow: 0 15px 25px rgba(0, 0, 0, 0.4); /* Stronger shadow */
            text-align: center;
            max-width: 90%;
            width: 550px; /* Slightly wider */
        }

        /* Toast notifications */
        #toast-container {
            position: fixed;
            bottom: 1.5rem; /* Slightly higher from bottom */
            right: 1.5rem; /* Slightly further from right */
            z-index: 1001;
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* More space between toasts */
        }
        .toast {
            background-color: #2b2b2b; /* Darker, more prominent toast */
            color: white;
            padding: 0.85rem 1.45rem; /* Slightly larger padding */
            border-radius: 0.5rem; /* More rounded */
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2); /* Clearer shadow */
            opacity: 0;
            animation: fadeIn 0.3s forwards, fadeOut 3s forwards 2s; /* Fade in, stay 2s, fade out */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(20px); }
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <!-- Game Over/Start Modal -->
    <div id="game-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 id="modal-title" class="text-3xl font-bold mb-4 text-amber-800">Karawana Burrito</h2>
            <p id="modal-message" class="text-lg text-gray-700 mb-6">Wyrusz w ekscytującą podróż przez pustynię, zbierając pakunki i rozbudowując swoją karawanę osiołków!</p>
            <button id="modal-button" class="px-8 py-4 bg-lime-600 text-white font-bold rounded-lg shadow-xl hover:bg-lime-700 transition-colors transform hover:scale-105">
                Rozpocznij Grę
            </button>
        </div>
    </div>

    <div id="game-container" class="flex flex-col lg:flex-row gap-8 w-full max-w-6xl hidden">
        <!-- Sidebar - Player Info and Game Log -->
        <div class="lg:w-1/3 flex flex-col gap-4">
            <!-- Player Info -->
            <div class="bg-white rounded-lg shadow-xl p-4">
                <h2 class="text-xl font-semibold mb-3 text-amber-800">Gracze</h2>
                <div id="players-info">
                    <!-- Player info will be rendered here by JavaScript -->
                </div>
            </div>

            <!-- Game Log -->
            <div class="bg-white rounded-lg shadow-xl p-4 flex-grow overflow-y-auto max-h-60 lg:max-h-[300px]">
                <h2 class="text-xl font-semibold mb-3 text-amber-800">Log Gry</h2>
                <div id="game-log" class="text-sm space-y-1">
                    <!-- Game log messages will be added here by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Main Game Area - Board and Controls -->
        <div class="lg:w-2/3 flex flex-col gap-6">
            <!-- Game Board -->
            <div class="bg-white rounded-lg shadow-xl p-4">
                <h2 class="text-xl font-semibold mb-3 text-amber-800">Plansza</h2>
                <div id="game-board" class="grid gap-0.5" style="grid-template-columns: repeat(7, minmax(0, 1fr));">
                    <!-- Game board tiles will be rendered here by JavaScript -->
                </div>
            </div>

            <!-- Game Controls -->
            <div class="bg-white rounded-lg shadow-xl p-4 flex flex-col sm:flex-row gap-4 justify-center items-center">
                <button id="next-turn-button" class="px-6 py-3 bg-orange-600 text-white font-bold rounded-lg shadow-lg hover:bg-orange-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105">
                    Wykonaj Ruch
                </button>
                <button id="use-bell-button" class="px-6 py-3 bg-teal-600 text-white font-bold rounded-lg shadow-lg hover:bg-teal-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105 hidden">
                    Użyj Dzwonka 🔔
                </button>
                <p id="game-status" class="text-lg font-semibold text-gray-700 mt-2"></p>
                <button id="restart-button" class="px-6 py-3 bg-red-600 text-white font-bold rounded-lg shadow-lg hover:bg-red-700 transition-colors transform hover:scale-105 hidden">
                    Zagraj Ponownie
                </button>
            </div>

            <!-- Legend -->
            <div class="bg-white rounded-lg shadow-xl p-4">
                <h2 class="text-xl font-semibold mb-3 text-amber-800">Legenda</h2>
                <div id="legend-info" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 text-sm">
                    <!-- Legend items will be rendered here by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toast-container"></div>

    <script>
        // --- UI ELEMENTS ---
        const gameModal = document.getElementById('game-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalButton = document.getElementById('modal-button');
        const gameContainer = document.getElementById('game-container');
        const gameBoardElement = document.getElementById('game-board');
        const playersInfoElement = document.getElementById('players-info');
        const gameLogElement = document.getElementById('game-log');
        const nextTurnButton = document.getElementById('next-turn-button');
        const useBellButton = document.getElementById('use-bell-button');
        const gameStatusElement = document.getElementById('game-status');
        const restartButton = document.getElementById('restart-button');
        const legendInfoElement = document.getElementById('legend-info');
        const toastContainer = document.getElementById('toast-container');


        // --- GAME CONSTANTS ---
        const BOARD_SIZE = 7;

        // --- GAME CLASSES AND OBJECTS ---

        // Tile class/object
        const Pole = (type, symbol, bonus = null) => ({ type, symbol, bonus });

        // Donkey class/object
        const Osiolek = (type) => ({ type });

        // Player class/object
        const Gracz = (name, leaderSymbol, caravanSymbol, startX, startY, isAI = false) => ({
            name,
            leaderSymbol,
            caravanSymbol,
            caravan: [{ x: startX, y: startY, osiolek: Osiolek('zwykly') }], // List of caravan segments
            points: 0,
            packages: [], // List of package names
            losesTurn: 0, // Number of turns to lose
            extraMoveNextTurn: 0, // Extra movement bonus for next turn
            donkeyAbilities: [], // List of ability types (e.g., 'twardziel', 'zlodziej', 'prorok', 'wloczega')
            equipment: [], // List of owned equipment (e.g., 'siodlo', 'sakwa', 'dzwonek')
            isAI,
            shadowCooldown: 0, // Cooldown for 'cien' donkey ability
            amuletActiveTurns: 0, // Turns Amulet is active for trap/bandit immunity
            mapaBonusActive: false, // Permanent +1 movement from Mapa
            bellCooldown: 0, // Cooldown for 'dzwonek' equipment
            prophetRevealedTile: null, // Stores a revealed tile for the Prorok ability
        });

        // --- GAME LOGIC FUNCTIONS ---

        // Board initialization
        const initializeBoard = (size) => {
            const board = Array.from({ length: size }, () => Array(size).fill(null).map(() => Pole('empty', '.')));

            // Packages (mixed types including new ones)
            board[1][1] = Pole('package', '📦', { points: 10, name: 'Wino' });
            board[5][5] = Pole('package', '📦', { points: 15, name: 'Przyprawy' });
            board[0][0] = Pole('package', '✨', { points: 5, name: 'Amulet' }); // New Amulet package
            board[6][0] = Pole('package', '🗺️', { points: 5, name: 'Mapa' });    // New Mapa package

            // Loose Donkeys
            board[2][5] = Pole('donkey', '🐴');
            board[3][4] = Pole('donkey', '🐴'); // Additional loose donkey

            // Food
            board[2][3] = Pole('food', '🍎');
            board[5][3] = Pole('food', '🍎');

            // Traps
            board[3][3] = Pole('trap', '☠️', { turnsLost: 1 });
            board[1][0] = Pole('trap', '☠️', { turnsLost: 1 });

            // Vineyards
            board[0][2] = Pole('vineyard', '🍇');
            board[6][4] = Pole('vineyard', '🍇');

            // Mountain Shortcuts (shortcut to package at (1,1))
            board[3][0] = Pole('mountain_shortcut', '🏔️', { targetX: 1, targetY: 1 });

            // Cacti
            board[4][1] = Pole('cactus', '🌵');
            board[0][1] = Pole('cactus', '🌵'); // Additional cactus

            // River and Bridges
            board[3][1] = Pole('river', '🌊');
            board[4][2] = Pole('bridge', '🌉');
            board[5][2] = Pole('river', '🌊');

            // Bazaar
            board[0][6] = Pole('bazar', '💰');

            // Fences
            board[2][2] = Pole('fence', '🚧');
            board[4][4] = Pole('fence', '🚧');

            // New: Bandolero (Bandits)
            board[1][3] = Pole('bandits', '🤠', { packagesLost: 1, donkeysLost: 1 });
            board[5][1] = Pole('bandits', '🤠', { packagesLost: 1, donkeysLost: 1 });

            // New: Well
            board[4][6] = Pole('well', '💧'); // Can give bonus or penalty
            board[1][6] = Pole('well', '💧');

            // New: Oasis
            board[6][3] = Pole('oasis', '🌴');
            board[0][3] = Pole('oasis', '🌴');


            // Special Donkeys (unique)
            board[1][5] = Pole('special_donkey', '⚪', { donkeyType: 'guide', name: 'Bialy Osiolek' }); // Guide Donkey
            board[4][0] = Pole('special_donkey', '⚫', { donkeyType: 'shadow', name: 'Czarny Osiolek' }); // Shadow Donkey
            board[6][1] = Pole('special_donkey', '🟫', { donkeyType: 'sturdy', name: 'Brazowy Osiolek' }); // Sturdy Donkey
            board[0][4] = Pole('special_donkey', '⬜', { donkeyType: 'stealthy', name: 'Szary Osiolek' }); // Stealthy Donkey (not active in this version)
            board[5][0] = Pole('special_donkey', '🌟', { donkeyType: 'prorok', name: 'Zloty Osiolek (Prorok)' }); // Prophet Donkey
            board[6][6] = Pole('special_donkey', '🎒', { donkeyType: 'wloczega', name: 'Zielony Osiolek (Wloczega)' }); // Wanderer Donkey

            return board;
        };

        // Manhattan distance calculation (used in AI)
        const calculateManhattanDistance = (x1, y1, x2, y2) => Math.abs(x1 - x2) + Math.abs(y1 - y2);

        // Checks if a player has a specific donkey ability
        const hasAbility = (player, abilityType) => player.donkeyAbilities.includes(abilityType);

        // Checks if a player has specific equipment
        const hasEquipment = (player, equipmentType) => player.equipment.includes(equipmentType);

        // Function to show toast notifications
        function showToast(message) {
            const toastDiv = document.createElement('div');
            toastDiv.classList.add('toast');
            toastDiv.textContent = message;
            toastContainer.appendChild(toastDiv);

            // Remove toast after animation
            setTimeout(() => {
                toastDiv.remove();
            }, 3000); // Match fadeOut animation duration
        }

        // Handles actions after landing on a tile
        const handleTileAction = (player, board, playersList) => {
            const { x, y } = player.caravan[0];
            const tile = board[x][y];
            let newLog = [];

            newLog.push(`  ${player.name} wszedl na pole: ${tile.type} (${tile.symbol})`);
            showToast(`${player.name} wszedl na pole: ${tile.type}`);


            switch (tile.type) {
                case 'package':
                    player.points += tile.bonus.points;
                    player.packages.push(tile.bonus.name);
                    newLog.push(`  ${player.name} zebral pakunek '${tile.bonus.name}'! Zdobyl ${tile.bonus.points} punktow.`);
                    showToast(`${player.name} zebral pakunek: ${tile.bonus.name}!`);
                    
                    // Special package effects
                    if (tile.bonus.name === 'Amulet') {
                        player.amuletActiveTurns = 3;
                        newLog.push(`  ${player.name} aktywowal Amulet! Chroniony przed pulapkami i Bandytami przez 3 tury.`);
                        showToast(`${player.name}: Amulet aktywny!`);
                    } else if (tile.bonus.name === 'Mapa') {
                        player.mapaBonusActive = true;
                        newLog.push(`  ${player.name} znalazl Mape! Zyskuje +1 staly ruch.`);
                        showToast(`${player.name}: Znalazl Mape!`);
                    }
                    board[x][y] = Pole('empty', '.'); // Package disappears
                    break;
                case 'donkey':
                    newLog.push(`  ${player.name} znalazl luznego osiolka! Dolacza go do karawany.`);
                    showToast(`${player.name}: Znalazl luznego osiolka!`);
                    player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek('zwykly') });
                    board[x][y] = Pole('empty', '.'); // Donkey disappears
                    break;
                case 'special_donkey':
                    newLog.push(`  ${player.name} znalazl ${tile.bonus.name}! Dolacza go do karawany.`);
                    showToast(`${player.name}: Znalazl specjalnego osiolka: ${tile.bonus.name}!`);
                    player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek(tile.bonus.donkeyType) });
                    player.donkeyAbilities.push(tile.bonus.donkeyType);
                    newLog.push(`  --> ${player.name} zdobywa umiejetnosc: ${tile.bonus.donkeyType.charAt(0).toUpperCase() + tile.bonus.donkeyType.slice(1)}!`);
                    showToast(`${player.name} zdobywa umiejetnosc: ${tile.bonus.donkeyType}!`);
                    board[x][y] = Pole('empty', '.'); // Special donkey disappears
                    break;
                case 'food':
                    newLog.push(`  ${player.name} wszedl na pole z jedzeniem! Rozmnazanie karawany...`);
                    showToast(`${player.name}: Jedzenie! Karawana sie rozrasta!`);
                    const donkeyTypes = ['zwykly', 'twardziel', 'zlodziej', 'prorok', 'wloczega'];
                    const newDonkeyType = donkeyTypes[Math.floor(Math.random() * donkeyTypes.length)];
                    player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek(newDonkeyType) });
                    if (newDonkeyType !== 'zwykly') {
                        player.donkeyAbilities.push(newDonkeyType);
                        newLog.push(`  Nowy osiolek dolaczony! Typ: ${newDonkeyType.charAt(0).toUpperCase() + newDonkeyType.slice(1)}!`);
                        showToast(`Nowy osiolek: ${newDonkeyType}!`);
                    } else {
                        newLog.push(`  Nowy osiolek dolaczony! Typ: Zwykly.`);
                        showToast(`Nowy osiolek: Zwykly!`);
                    }
                    board[x][y] = Pole('empty', '.'); // Food disappears
                    break;
                case 'trap':
                    if (player.amuletActiveTurns > 0) {
                        newLog.push(`  ${player.name} wszedl w pulapke, ale zostal ochroniony przez Amulet!`);
                        showToast(`${player.name}: Amulet chroni przed pulapka!`);
                    } else if (!hasAbility(player, 'twardziel')) {
                        player.losesTurn += tile.bonus.turnsLost;
                        newLog.push(`  ${player.name} wpadl w pulapke! Traci ${tile.bonus.turnsLost} ture/tury.`);
                        showToast(`${player.name}: Wpadl w pulapke! Traci ture!`);
                    } else {
                        newLog.push(`  ${player.name} wszedl w pulapke, ale jego Sturdy Donkey go uratowal!`);
                        showToast(`${player.name}: Sturdy Donkey ratuje przed pulapka!`);
                    }
                    break;
                case 'vineyard':
                    player.extraMoveNextTurn += 1;
                    newLog.push(`  ${player.name} wszedl na winnice! Zyskuje +1 ruch w nastepnej turze.`);
                    showToast(`${player.name}: Winnica! +1 ruch w nast. turze!`);
                    break;
                case 'mountain_shortcut':
                    const { targetX, targetY } = tile.bonus;
                    newLog.push(`  ${player.name} uzyl gorskiego skrotu! Przeniosl sie na pole (${targetX + 1}, ${targetY + 1}).`);
                    showToast(`${player.name}: Skrot! Teleport do (${targetX + 1}, ${targetY + 1})!`);
                    // Teleport head
                    const currentHeadOsiolek = player.caravan[0].osiolek;
                    player.caravan[0] = { x: targetX, y: targetY, osiolek: currentHeadOsiolek };
                    // Other donkeys follow (simplified: appear behind leader at new location)
                    for (let i = 1; i < player.caravan.length; i++) {
                        const prevSeg = player.caravan[i - 1];
                        player.caravan[i] = {
                            x: prevSeg.x - (prevSeg.x > 0 ? 1 : 0), // Simple trailing logic
                            y: prevSeg.y,
                            osiolek: player.caravan[i].osiolek
                        };
                    }
                    break;
                case 'bazar':
                    newLog.push(`  ${player.name} jest na Bazarze. Tutaj mozesz sprzedac pakunki (5 pts/each)!`);
                    showToast(`${player.name}: Bazar! Sprzedaj pakunki!`);
                    if (player.packages.length > 0) {
                        const soldPackage = player.packages.pop();
                        player.points += 5;
                        newLog.push(`  ${player.name} sprzedal '${soldPackage}' za 5 punktow.`);
                        showToast(`${player.name}: Sprzedal '${soldPackage}'!`);
                    } else {
                        newLog.push("  Nie masz pakunkow do sprzedania.");
                    }
                    break;
                case 'cactus':
                    newLog.push(`  ${player.name} wszedl na kaktusa! Ruch w nastepnej turze moze byc spowolniony.`);
                    showToast(`${player.name}: Kaktus! Ruch spowolniony!`);
                    break;
                case 'river':
                    newLog.push(`  ${player.name} wszedl na rzeke! To pole jest nieprzechodnie.`);
                    showToast(`${player.name}: Rzeka! Nieprzechodnie!`);
                    player.losesTurn += 1; // Penalty for entering impassable tile
                    break;
                case 'fence':
                    newLog.push(`  ${player.name} wszedl na plot! To pole jest nieprzechodnie.`);
                    showToast(`${player.name}: Plot! Nieprzechodnie!`);
                    player.losesTurn += 1; // Penalty for entering impassable tile
                    break;
                case 'bandits': // New Bandolero tile logic
                    if (player.amuletActiveTurns > 0) {
                        newLog.push(`  ${player.name} spotkal Bandytow, ale zostal ochroniony przez Amulet!`);
                        showToast(`${player.name}: Amulet chroni przed Bandytami!`);
                    } else if (hasAbility(player, 'sturdy')) {
                        newLog.push(`  ${player.name} spotkal Bandytow, ale jego Sturdy Donkey odstraszyl ich!`);
                        showToast(`${player.name}: Sturdy Donkey odstrasza Bandytow!`);
                    } else {
                        const lostItemType = Math.random() < 0.5 ? 'package' : 'donkey';
                        if (lostItemType === 'package' && player.packages.length > 0) {
                            const lostPackage = player.packages.pop();
                            newLog.push(`  ${player.name} spotkal Bandytow! Stracil pakunek: '${lostPackage}'.`);
                            showToast(`${player.name}: Bandyci! Stracil '${lostPackage}'!`);
                        } else if (lostItemType === 'donkey' && player.caravan.length > 1) {
                            const lostDonkey = player.caravan.pop();
                            newLog.push(`  ${player.name} spotkal Bandytow! Stracil osiolka.`);
                            showToast(`${player.name}: Bandyci! Stracil osiolka!`);
                        } else {
                            newLog.push(`  ${player.name} spotkal Bandytow, ale nic nie stracil (brak pakunkow/osiolkow).`);
                            showToast(`${player.name}: Bandyci... ale nic nie stracil!`);
                        }
                    }
                    break;
                case 'well': // New Well tile logic
                    const wellOutcome = Math.random();
                    if (wellOutcome < 0.4) { // 40% chance for bonus donkey
                        newLog.push(`  ${player.name} znalazl Studnie! Zyskuje nowego osiolka!`);
                        showToast(`${player.name}: Studnia! Nowy osiolek!`);
                        const donkeyTypes = ['zwykly', 'twardziel', 'zlodziej'];
                        const newDonkeyType = donkeyTypes[Math.floor(Math.random() * donkeyTypes.length)];
                        player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek(newDonkeyType) });
                        if (newDonkeyType !== 'zwykly') {
                            player.donkeyAbilities.push(newDonkeyType);
                            newLog.push(`  Nowy osiolek dolaczony! Typ: ${newDonkeyType.charAt(0).toUpperCase() + newDonkeyType.slice(1)}!`);
                            showToast(`Nowy osiolek: ${newDonkeyType}!`);
                        }
                    } else if (wellOutcome < 0.7) { // 30% chance for extra move next turn
                        newLog.push(`  ${player.name} znalazl Studnie! Zyskuje +1 ruch w nastepnej turze.`);
                        showToast(`${player.name}: Studnia! +1 ruch w nast. turze!`);
                    } else { // 30% chance for losing a turn
                        newLog.push(`  ${player.name} znalazl Studnie! Niestety, traci 1 ture.`);
                        showToast(`${player.name}: Studnia... Traci ture!`);
                        player.losesTurn += 1;
                    }
                    break;
                case 'oasis': // New Oasis tile logic
                    newLog.push(`  ${player.name} wszedl na Oaze! Zyskuje +1 ruch w tej turze!`);
                    showToast(`${player.name}: Oaza! +1 ruch w tej turze!`);
                    // This bonus is applied immediately for calculation, then reset.
                    player.extraMoveNextTurn += 1; // This will be consumed by calculatePossibleMoves for the current turn
                    break;
                default:
                    break;
            }

            // 'Zlodziej' (Thief) Donkey activation (if player has it and another player has packages)
            if (hasAbility(player, 'zlodziej')) {
                if (Math.random() < 0.2) { // 20% chance to activate thief ability
                    newLog.push(`  ${player.name} probuje aktywowac Thief Donkey...`);
                    showToast(`${player.name}: Thief Donkey probuje krasc!`);
                    for (const otherPlayer of playersList) {
                        if (otherPlayer !== player && otherPlayer.packages.length > 0) {
                            const stolenPackage = otherPlayer.packages.pop();
                            player.packages.push(stolenPackage);
                            player.points += 5; // Bonus for stealing
                            newLog.push(`  --> SUKCES! ${player.name} ukradl '${stolenPackage}' od ${otherPlayer.name}! Zyskal 5 punktow.`);
                            showToast(`${player.name}: Ukradl '${stolenPackage}' od ${otherPlayer.name}!`);
                            break;
                        }
                    }
                }
            }
            gameLog.push(...newLog); // Add new logs to the main game log
            updateGameLogUI();
        };

        // Finds the closest interesting tile for Prorok ability
        const findClosestInterestingTile = (player, board, size, maxDistance = 3) => {
            const { x: currentX, y: currentY } = player.caravan[0];
            let closestTile = null;
            let minDistance = Infinity;

            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const tile = board[r][c];
                    const distance = calculateManhattanDistance(currentX, currentY, r, c);

                    if (distance > 0 && distance <= maxDistance) {
                        if (tile.type === 'package' || tile.type === 'food' || tile.type === 'donkey' || tile.type === 'special_donkey') {
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestTile = { x: r, y: c, type: tile.type, symbol: tile.symbol };
                            }
                        }
                    }
                }
            }
            return closestTile;
        };


        // Calculates possible moves for a player
        const calculatePossibleMoves = (player, board, size) => {
            const { x: currentX, y: currentY } = player.caravan[0];
            let possibleMoves = [];
            let baseMovement = 2; // Default movement

            // Add movement bonus from vineyard, equipment, or Mapa
            baseMovement += player.extraMoveNextTurn; // Consumed here for the current turn
            if (hasEquipment(player, 'sakwa')) {
                baseMovement += 1;
            }
            if (player.mapaBonusActive) { // Permanent +1 movement from Mapa
                baseMovement += 1;
            }
            
            // Note: player.extraMoveNextTurn is reset in nextTurn() after the move, not here.
            // This ensures Oasis bonus is applied to *this* turn's movement calculation,
            // but cleared before the next turn.

            // Ensure movement is not less than 1
            const actualMovement = Math.max(1, baseMovement);

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // Up, Down, Right, Left

            for (const [dx, dy] of directions) {
                for (let step = 1; step <= actualMovement; step++) {
                    const nextX = currentX + dx * step;
                    const nextY = currentY + dy * step;

                    if (nextX >= 0 && nextX < size && nextY >= 0 && nextY < size) {
                        const tile = board[nextX][nextY];
                        let cost = step;

                        // Cactus costs 1 extra move, UNLESS player has 'wloczega' ability
                        if (tile.type === 'cactus' && !hasAbility(player, 'wloczega')) {
                            cost += 1;
                        }
                        
                        // River and Fence are impassable, unless it's a Bridge
                        let blockedPath = false;
                        for (let i = 1; i <= step; i++) {
                            const intermediateX = currentX + dx * i;
                            const intermediateY = currentY + dy * i;
                            if (intermediateX < 0 || intermediateX >= size || intermediateY < 0 || intermediateY >= size) {
                                blockedPath = true; // Path out of bounds is blocked
                                break;
                            }
                            const intermediateTile = board[intermediateX][intermediateY];
                            if (intermediateTile.type === 'fence' || (intermediateTile.type === 'river' && intermediateTile.type !== 'bridge')) {
                                blockedPath = true;
                                break;
                            }
                        }
                        if(blockedPath) continue; // Don't add this move if the path is blocked
                        
                        if (cost <= actualMovement) {
                            possibleMoves.push({ x: nextX, y: nextY, cost: cost });
                        }
                    }
                }
            }
            return possibleMoves;
        };

        // AI movement logic
        const aiMove = (player, board, playersList, size) => {
            const { x: currentX, y: currentY } = player.caravan[0];
            let currentTurnPossibleMoves = calculatePossibleMoves(player, board, size); // AI calculates its moves
            
            // After calculating possible moves, reset extraMoveNextTurn for this player
            // This ensures Oasis bonus is consumed for this AI player's turn only.
            player.extraMoveNextTurn = 0;


            if (currentTurnPossibleMoves.length === 0) {
                gameLog.push(`  ${player.name} (AI) has no possible moves.`);
                showToast(`${player.name} (AI) nie ma ruchow.`);
                updateGameLogUI();
                return;
            }

            let bestMove = null;
            let highestPriority = -Infinity;

            // --- AI Decision Making ---
            // 1. Prioritize using Bell if available and useful
            if (hasEquipment(player, 'dzwonek') && player.bellCooldown === 0) {
                const closestLooseDonkey = findClosestLooseDonkey(player, board, size, 2); // Check 2-tile radius
                if (closestLooseDonkey) {
                    const emptyAdjacent = findEmptyAdjacentTile(player.caravan[0].x, player.caravan[0].y, board, size);
                    if (emptyAdjacent) {
                        // High priority to use bell if it brings a donkey and there's space
                        // This will effectively be the "best move" if conditions are met
                        console.log(`AI: Decyduje sie uzyc Dzwonka, by przyciagnac osiolka z (${closestLooseDonkey.x + 1}, ${closestLooseDonkey.y + 1}).`);
                        useBell(player, board, size); // Directly call bell function for AI
                        return; // AI's turn is consumed by using the bell
                    }
                }
            }
            
            // 2. Evaluate moves based on tile priority
            for (const move of currentTurnPossibleMoves) {
                const { x: targetX, y: targetY } = mo
