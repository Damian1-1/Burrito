<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karawana Burrito - Rozszerzona Wersja</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game, overriding Tailwind */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f7ede2; /* Lighter, sandy background for the whole page */
        }
        /* Specific styling for the game board grid items for better visuals */
        .grid-item {
            width: 3rem; /* Fixed width for tiles */
            height: 3rem; /* Fixed height for tiles */
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.25rem; /* rounded-sm */
            text-align: center;
            font-size: 0.75rem; /* text-xs */
            background-color: #fcf6e6; /* Very light sandy for empty tiles */
            position: relative;
        }

        /* Responsive adjustments for larger screens if necessary, overriding fixed size */
        @media (min-width: 768px) {
            .grid-item {
                width: 4rem; /* Larger tiles on medium screens */
                height: 4rem;
                font-size: 0.875rem; /* text-sm */
            }
        }
        @media (min-width: 1024px) {
            .grid-item {
                width: 5rem; /* Even larger tiles on large screens */
                height: 5rem;
                font-size: 1rem; /* text-base */
            }
        }
        .bandit-symbol {
            position: absolute;
            bottom: 0;
            right: 0;
            font-size: 1.25rem; /* text-xl */
            line-height: 1;
        }

        /* Modal specific styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 2.5rem; /* Slightly more padding */
            border-radius: 0.75rem; /* More rounded */
            box-shadow: 0 15px 25px rgba(0, 0, 0, 0.4); /* Stronger shadow */
            text-align: center;
            max-width: 90%;
            width: 550px; /* Slightly wider */
        }

        /* Toast notifications */
        #toast-container {
            position: fixed;
            bottom: 1.5rem; /* Slightly higher from bottom */
            right: 1.5rem; /* Slightly further from right */
            z-index: 1001;
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* More space between toasts */
        }
        .toast {
            background-color: #2b2b2b; /* Darker, more prominent toast */
            color: white;
            padding: 0.85rem 1.45rem; /* Slightly larger padding */
            border-radius: 0.5rem; /* More rounded */
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2); /* Clearer shadow */
            opacity: 0;
            animation: fadeIn 0.3s forwards, fadeOut 3s forwards 2s; /* Fade in, stay 2s, fade out */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(20px); }
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <div id="game-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 id="modal-title" class="text-3xl font-bold mb-4 text-amber-800">Karawana Burrito</h2>
            <p id="modal-message" class="text-lg text-gray-700 mb-6">Wyrusz w ekscytujÄ…cÄ… podrÃ³Å¼ przez pustyniÄ™, zbierajÄ…c pakunki i rozbudowujÄ…c swojÄ… karawanÄ™ osioÅ‚kÃ³w!</p>
            <button id="modal-button" class="px-8 py-4 bg-lime-600 text-white font-bold rounded-lg shadow-xl hover:bg-lime-700 transition-colors transform hover:scale-105">
                Rozpocznij GrÄ™
            </button>
        </div>
    </div>

    <div id="event-modal" class="modal-overlay hidden">
        <div class="modal-content bg-gray-900 text-white border-4 border-yellow-500">
            <h2 class="text-3xl font-bold mb-4 text-yellow-400">Karta Zdarzenia!</h2>
            <p id="event-message" class="text-lg text-gray-200 mb-6"></p>
            <button id="event-close-button" class="px-6 py-3 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition-colors">
                OK
            </button>
        </div>
    </div>

    <div id="game-container" class="flex flex-col lg:flex-row gap-8 w-full max-w-6xl hidden">
        <div class="lg:w-1/3 flex flex-col gap-4">
            <div class="bg-white rounded-lg shadow-xl p-4">
                <h2 class="text-xl font-semibold mb-3 text-amber-800">Gracze</h2>
                <div id="players-info">
                    </div>
            </div>

            <div class="bg-white rounded-lg shadow-xl p-4 flex-grow overflow-y-auto max-h-60 lg:max-h-[300px]">
                <h2 class="text-xl font-semibold mb-3 text-amber-800">Log Gry</h2>
                <div id="game-log" class="text-sm space-y-1">
                    </div>
            </div>
        </div>

        <div class="lg:w-2/3 flex flex-col gap-6">
            <div class="bg-white rounded-lg shadow-xl p-4">
                <h2 class="text-xl font-semibold mb-3 text-amber-800">Plansza</h2>
                <div id="game-board" class="grid gap-0.5" style="grid-template-columns: repeat(7, minmax(0, 1fr));">
                    </div>
            </div>

            <div class="bg-white rounded-lg shadow-xl p-4 flex flex-col sm:flex-row gap-4 justify-center items-center">
                <button id="next-turn-button" class="px-6 py-3 bg-orange-600 text-white font-bold rounded-lg shadow-lg hover:bg-orange-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105">
                    Wykonaj Ruch
                </button>
                <button id="use-bell-button" class="px-6 py-3 bg-teal-600 text-white font-bold rounded-lg shadow-lg hover:bg-teal-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105 hidden">
                    UÅ¼yj Dzwonka ðŸ””
                </button>
                <button id="use-shadow-button" class="px-6 py-3 bg-gray-800 text-white font-bold rounded-lg shadow-lg hover:bg-gray-900 transition-colors disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105 hidden">
                    UÅ¼yj Cienia âš«
                </button>
                <p id="game-status" class="text-lg font-semibold text-gray-700 mt-2"></p>
                <button id="restart-button" class="px-6 py-3 bg-red-600 text-white font-bold rounded-lg shadow-lg hover:bg-red-700 transition-colors transform hover:scale-105 hidden">
                    Zagraj Ponownie
                </button>
            </div>

            <div class="bg-white rounded-lg shadow-xl p-4">
                <h2 class="text-xl font-semibold mb-3 text-amber-800">Legenda</h2>
                <div id="legend-info" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 text-sm">
                    </div>
            </div>
        </div>
    </div>

    <div id="toast-container"></div>

    <script>
        // --- UI ELEMENTS ---
        const gameModal = document.getElementById('game-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalButton = document.getElementById('modal-button');
        const eventModal = document.getElementById('event-modal');
        const eventMessage = document.getElementById('event-message');
        const eventCloseButton = document.getElementById('event-close-button');
        const gameContainer = document.getElementById('game-container');
        const gameBoardElement = document.getElementById('game-board');
        const playersInfoElement = document.getElementById('players-info');
        const gameLogElement = document.getElementById('game-log');
        const nextTurnButton = document.getElementById('next-turn-button');
        const useBellButton = document.getElementById('use-bell-button');
        const useShadowButton = document.getElementById('use-shadow-button');
        const gameStatusElement = document.getElementById('game-status');
        const restartButton = document.getElementById('restart-button');
        const legendInfoElement = document.getElementById('legend-info');
        const toastContainer = document.getElementById('toast-container');


        // --- GAME CONSTANTS ---
        const BOARD_SIZE = 7;
        const EVENT_INTERVAL = 5; // Event card every 5 turns

        // --- GAME CLASSES AND OBJECTS ---

        // Tile class/object
        const Pole = (type, symbol, bonus = null) => ({ type, symbol, bonus });

        // Donkey class/object
        const Osiolek = (type) => ({ type });

        // Player class/object
        const Gracz = (name, leaderSymbol, caravanSymbol, startX, startY, isAI = false) => ({
            name,
            leaderSymbol,
            caravanSymbol,
            caravan: [{ x: startX, y: startY, osiolek: Osiolek('zwykly') }], // List of caravan segments
            points: 0,
            packages: [], // List of package names
            losesTurn: 0, // Number of turns to lose
            extraMoveNextTurn: 0, // Extra movement bonus for next turn
            donkeyAbilities: [], // List of ability types (e.g., 'twardziel', 'zlodziej', 'prorok', 'wloczega')
            equipment: [], // List of owned equipment (e.g., 'siodlo', 'sakwa', 'dzwonek')
            isAI,
            shadowCooldown: 0, // Cooldown for 'cien' donkey ability
            amuletActiveTurns: 0, // Turns Amulet is active for trap/bandit immunity
            mapaBonusActive: false, // Permanent +1 movement from Mapa
            bellCooldown: 0, // Cooldown for 'dzwonek' equipment
            prophetRevealedTile: null, // Stores a revealed tile for the Prorok ability
            role: 'Brak Roli', // Player role
            shadowTarget: null, // To store the package to be moved by 'Cien'
        });

        // Bandit NPC object
        let bandit = {
            x: 0,
            y: 3,
            symbol: 'ðŸ¤ ',
            packagesLost: 1,
            donkeysLost: 1,
            isMoving: true
        };

        // --- GAME LOGIC FUNCTIONS ---

        // Board initialization
        const initializeBoard = (size) => {
            const board = Array.from({ length: size }, () => Array(size).fill(null).map(() => Pole('empty', '.')));

            // Packages (mixed types including new ones)
            board[1][1] = Pole('package', 'ðŸ“¦', { points: 10, name: 'Wino' });
            board[5][5] = Pole('package', 'ðŸ“¦', { points: 15, name: 'Przyprawy' });
            board[0][0] = Pole('package', 'âœ¨', { points: 5, name: 'Amulet' }); // New Amulet package
            board[6][0] = Pole('package', 'ðŸ—ºï¸', { points: 5, name: 'Mapa' });    // New Mapa package
            board[2][0] = Pole('package', 'ðŸ’Ž', { points: 50, name: 'Skarb' }); // Treasure chest!

            // Loose Donkeys
            board[2][5] = Pole('donkey', 'ðŸ´');
            board[3][4] = Pole('donkey', 'ðŸ´'); // Additional loose donkey

            // Food
            board[2][3] = Pole('food', 'ðŸŽ');
            board[5][3] = Pole('food', 'ðŸŽ');

            // Traps
            board[3][3] = Pole('trap', 'â˜ ï¸', { turnsLost: 1 });
            board[1][0] = Pole('trap', 'â˜ ï¸', { turnsLost: 1 });

            // Vineyards
            board[0][2] = Pole('vineyard', 'ðŸ‡');
            board[6][4] = Pole('vineyard', 'ðŸ‡');

            // Mountain Shortcuts
            board[3][0] = Pole('mountain_shortcut', 'ðŸ”ï¸', { targetX: 1, targetY: 1 });

            // Cacti
            board[4][1] = Pole('cactus', 'ðŸŒµ');
            board[0][1] = Pole('cactus', 'ðŸŒµ'); // Additional cactus

            // River and Bridges
            board[3][1] = Pole('river', 'ðŸŒŠ');
            board[4][2] = Pole('bridge', 'ðŸŒ‰');
            board[5][2] = Pole('river', 'ðŸŒŠ');

            // Bazaar
            board[0][6] = Pole('bazar', 'ðŸ’°');

            // Fences
            board[2][2] = Pole('fence', 'ðŸš§');
            board[4][4] = Pole('fence', 'ðŸš§');

            // New: Bandolero (Bandits)
            board[1][3] = Pole('bandits', 'ðŸ¤ ', { packagesLost: 1, donkeysLost: 1 });
            board[5][1] = Pole('bandits', 'ðŸ¤ ', { packagesLost: 1, donkeysLost: 1 });
            // The Bandit NPC itself is handled separately, but these tiles can still be there

            // New: Well
            board[4][6] = Pole('well', 'ðŸ’§'); // Can give bonus or penalty
            board[1][6] = Pole('well', 'ðŸ’§');

            // New: Oasis
            board[6][3] = Pole('oasis', 'ðŸŒ´');
            board[0][3] = Pole('oasis', 'ðŸŒ´');

            // New Tiles from detailed summary
            board[4][5] = Pole('fishing_village', 'ðŸŽ£'); // Fishing Village
            board[1][4] = Pole('hermitage', 'ðŸ '); // Hermitage
            board[5][6] = Pole('mystery_shrine', 'âœ¨'); // Mystery Shrine

            // Special Donkeys (unique)
            board[1][5] = Pole('special_donkey', 'âšª', { donkeyType: 'guide', name: 'Bialy Osiolek' }); // Guide Donkey
            board[4][0] = Pole('special_donkey', 'âš«', { donkeyType: 'shadow', name: 'Czarny Osiolek' }); // Shadow Donkey
            board[6][1] = Pole('special_donkey', 'ðŸŸ«', { donkeyType: 'sturdy', name: 'Brazowy Osiolek' }); // Sturdy Donkey
            board[0][4] = Pole('special_donkey', 'â¬œ', { donkeyType: 'stealthy', name: 'Szary Osiolek' }); // Stealthy Donkey (not active in this version)
            board[5][0] = Pole('special_donkey', 'ðŸŒŸ', { donkeyType: 'prorok', name: 'Zloty Osiolek (Prorok)' }); // Prophet Donkey
            board[6][6] = Pole('special_donkey', 'ðŸŽ’', { donkeyType: 'wloczega', name: 'Zielony Osiolek (Wloczega)' }); // Wanderer Donkey

            return board;
        };

        // Event card data
        const eventCards = [
            {
                name: "Burza Piaskowa",
                description: "Silna burza piaskowa przeszkadza w podrÃ³Å¼y! Wszyscy gracze tracÄ… 1 turÄ™.",
                effect: (players, log) => {
                    players.forEach(p => p.losesTurn += 1);
                    log.push("Burza Piaskowa! Wszyscy tracÄ… 1 turÄ™.");
                }
            },
            {
                name: "Znaleziony Skarb",
                description: "Na planszy pojawia siÄ™ dodatkowy, cenny pakunek! Szukajcie skarbu!",
                effect: (players, log, board, size) => {
                    const emptyTiles = [];
                    board.forEach((row, x) => row.forEach((tile, y) => {
                        if (tile.type === 'empty') emptyTiles.push({ x, y });
                    }));
                    if (emptyTiles.length > 0) {
                        const { x, y } = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
                        board[x][y] = Pole('package', 'ðŸ’°', { points: 40, name: 'Skarb' });
                        log.push(`Na planszy pojawil sie nowy pakunek - Skarb na polu (${x + 1}, ${y + 1})!`);
                    }
                }
            },
            {
                name: "Karawana Handlarza",
                description: "Karawana handlarza przejeÅ¼dÅ¼a obok! KaÅ¼dy gracz z pakunkiem otrzymuje +5 punktÃ³w.",
                effect: (players, log) => {
                    players.forEach(p => {
                        if (p.packages.length > 0) {
                            p.points += 5;
                            log.push(`${p.name} zyskal 5 punktow od handlarza.`);
                        }
                    });
                }
            },
            {
                name: "Epidemia",
                description: "Choroba w stadzie! KaÅ¼dy gracz traci 1 losowego osioÅ‚ka, jeÅ›li ma wiÄ™cej niÅ¼ jednego.",
                effect: (players, log) => {
                    players.forEach(p => {
                        if (p.caravan.length > 1) {
                            const removedOsiolek = p.caravan.pop();
                            log.push(`${p.name} stracil osiolka typu: ${removedOsiolek.osiolek.type}.`);
                        }
                    });
                }
            }
        ];

        // Player roles data
        const roles = [
            { name: "Kupiec", description: "Otrzymuje 10 punktÃ³w za kaÅ¼dy pakunek na Bazarze zamiast 5.", bonus: (player) => player.role === 'Kupiec' },
            { name: "Farmer", description: "Zyskuje dodatkowego osioÅ‚ka z jedzenia i pÃ³l rolnych.", bonus: (player) => player.role === 'Farmer' },
            { name: "Odkrywca", description: "Zyskuje +1 do ruchu.", bonus: (player) => player.role === 'Odkrywca' },
        ];


        // Manhattan distance calculation (used in AI)
        const calculateManhattanDistance = (x1, y1, x2, y2) => Math.abs(x1 - x2) + Math.abs(y1 - y2);

        // Checks if a player has a specific donkey ability
        const hasAbility = (player, abilityType) => player.donkeyAbilities.includes(abilityType);

        // Checks if a player has specific equipment
        const hasEquipment = (player, equipmentType) => player.equipment.includes(equipmentType);

        // Function to show toast notifications
        function showToast(message) {
            const toastDiv = document.createElement('div');
            toastDiv.classList.add('toast');
            toastDiv.textContent = message;
            toastContainer.appendChild(toastDiv);

            // Remove toast after animation
            setTimeout(() => {
                toastDiv.remove();
            }, 3000); // Match fadeOut animation duration
        }

        // Handles actions after landing on a tile
        const handleTileAction = (player, board, playersList) => {
            const { x, y } = player.caravan[0];
            const tile = board[x][y];
            let newLog = [];

            newLog.push(`  ${player.name} wszedl na pole: ${tile.type} (${tile.symbol})`);
            showToast(`${player.name} wszedl na pole: ${tile.type}`);


            switch (tile.type) {
                case 'package':
                    player.points += tile.bonus.points;
                    player.packages.push(tile.bonus.name);
                    newLog.push(`  ${player.name} zebral pakunek '${tile.bonus.name}'! Zdobyl ${tile.bonus.points} punktow.`);
                    showToast(`${player.name} zebral pakunek: ${tile.bonus.name}!`);
                    
                    // Special package effects
                    if (tile.bonus.name === 'Amulet') {
                        player.amuletActiveTurns = 3;
                        newLog.push(`  ${player.name} aktywowal Amulet! Chroniony przed pulapkami i Bandytami przez 3 tury.`);
                        showToast(`${player.name}: Amulet aktywny!`);
                    } else if (tile.bonus.name === 'Mapa') {
                        player.mapaBonusActive = true;
                        newLog.push(`  ${player.name} znalazl Mape! Zyskuje +1 staly ruch.`);
                        showToast(`${player.name}: Znalazl Mape!`);
                    }
                    board[x][y] = Pole('empty', '.'); // Package disappears
                    break;
                case 'donkey':
                    newLog.push(`  ${player.name} znalazl luznego osiolka! Dolacza go do karawany.`);
                    showToast(`${player.name}: Znalazl luznego osiolka!`);
                    player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek('zwykly') });
                    board[x][y] = Pole('empty', '.'); // Donkey disappears
                    break;
                case 'special_donkey':
                    newLog.push(`  ${player.name} znalazl ${tile.bonus.name}! Dolacza go do karawany.`);
                    showToast(`${player.name}: Znalazl specjalnego osiolka: ${tile.bonus.name}!`);
                    player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek(tile.bonus.donkeyType) });
                    player.donkeyAbilities.push(tile.bonus.donkeyType);
                    newLog.push(`  --> ${player.name} zdobywa umiejetnosc: ${tile.bonus.donkeyType.charAt(0).toUpperCase() + tile.bonus.donkeyType.slice(1)}!`);
                    showToast(`${player.name} zdobywa umiejetnosc: ${tile.bonus.donkeyType}!`);
                    board[x][y] = Pole('empty', '.'); // Special donkey disappears
                    break;
                case 'food':
                    newLog.push(`  ${player.name} wszedl na pole z jedzeniem! Rozmnazanie karawany...`);
                    showToast(`${player.name}: Jedzenie! Karawana sie rozrasta!`);
                    const donkeyTypes = ['zwykly', 'twardziel', 'zlodziej', 'prorok', 'wloczega'];
                    const newDonkeyType = donkeyTypes[Math.floor(Math.random() * donkeyTypes.length)];
                    player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek(newDonkeyType) });
                    if (newDonkeyType !== 'zwykly') {
                        player.donkeyAbilities.push(newDonkeyType);
                        newLog.push(`  Nowy osiolek dolaczony! Typ: ${newDonkeyType.charAt(0).toUpperCase() + newDonkeyType.slice(1)}!`);
                        showToast(`Nowy osiolek: ${newDonkeyType}!`);
                    } else {
                        newLog.push(`  Nowy osiolek dolaczony! Typ: Zwykly.`);
                        showToast(`Nowy osiolek: Zwykly!`);
                    }
                    board[x][y] = Pole('empty', '.'); // Food disappears
                    break;
                case 'trap':
                    if (player.amuletActiveTurns > 0) {
                        newLog.push(`  ${player.name} wszedl w pulapke, ale zostal ochroniony przez Amulet!`);
                        showToast(`${player.name}: Amulet chroni przed pulapka!`);
                    } else if (!hasAbility(player, 'twardziel')) {
                        player.losesTurn += tile.bonus.turnsLost;
                        newLog.push(`  ${player.name} wpadl w pulapke! Traci ${tile.bonus.turnsLost} ture/tury.`);
                        showToast(`${player.name}: Wpadl w pulapke! Traci ture!`);
                    } else {
                        newLog.push(`  ${player.name} wszedl w pulapke, ale jego Sturdy Donkey go uratowal!`);
                        showToast(`${player.name}: Sturdy Donkey ratuje przed pulapka!`);
                    }
                    break;
                case 'vineyard':
                    player.extraMoveNextTurn += 1;
                    newLog.push(`  ${player.name} wszedl na winnice! Zyskuje +1 ruch w nastepnej turze.`);
                    showToast(`${player.name}: Winnica! +1 ruch w nast. turze!`);
                    break;
                case 'mountain_shortcut':
                    const { targetX, targetY } = tile.bonus;
                    newLog.push(`  ${player.name} uzyl gorskiego skrotu! Przeniosl sie na pole (${targetX + 1}, ${targetY + 1}).`);
                    showToast(`${player.name}: Skrot! Teleport do (${targetX + 1}, ${targetY + 1})!`);
                    // Teleport head
                    const currentHeadOsiolek = player.caravan[0].osiolek;
                    player.caravan[0] = { x: targetX, y: targetY, osiolek: currentHeadOsiolek };
                    // Other donkeys follow (simplified: appear behind leader at new location)
                    for (let i = 1; i < player.caravan.length; i++) {
                        const prevSeg = player.caravan[i - 1];
                        player.caravan[i] = {
                            x: prevSeg.x - (prevSeg.x > 0 ? 1 : 0), // Simple trailing logic
                            y: prevSeg.y,
                            osiolek: player.caravan[i].osiolek
                        };
                    }
                    break;
                case 'bazar':
                    newLog.push(`  ${player.name} jest na Bazarze. Tutaj mozesz sprzedac pakunki!`);
                    showToast(`${player.name}: Bazar! Sprzedaj pakunki!`);
                    if (player.packages.length > 0) {
                        const pointsPerPackage = player.role === 'Kupiec' ? 10 : 5;
                        const soldPackage = player.packages.pop();
                        player.points += pointsPerPackage;
                        newLog.push(`  ${player.name} sprzedal '${soldPackage}' za ${pointsPerPackage} punktow.`);
                        showToast(`${player.name}: Sprzedal '${soldPackage}'!`);
                    } else {
                        newLog.push("  Nie masz pakunkow do sprzedania.");
                    }
                    break;
                case 'cactus':
                    newLog.push(`  ${player.name} wszedl na kaktusa! Ruch w nastepnej turze moze byc spowolniony.`);
                    showToast(`${player.name}: Kaktus! Ruch spowolniony!`);
                    break;
                case 'river':
                case 'fence':
                    newLog.push(`  ${player.name} wszedl na to pole, ale jest ono nieprzechodnie! Traci ture.`);
                    showToast(`${player.name}: Pole nieprzechodnie!`);
                    player.losesTurn += 1;
                    break;
                case 'bandits':
                    if (player.amuletActiveTurns > 0) {
                        newLog.push(`  ${player.name} spotkal Bandytow, ale zostal ochroniony przez Amulet!`);
                        showToast(`${player.name}: Amulet chroni przed Bandytami!`);
                    } else if (hasAbility(player, 'sturdy')) {
                        newLog.push(`  ${player.name} spotkal Bandytow, ale jego Twardy Osiolek odstraszyl ich!`);
                        showToast(`${player.name}: Twardy Osiolek odstrasza Bandytow!`);
                    } else {
                        const lostItemType = Math.random() < 0.5 ? 'package' : 'donkey';
                        if (lostItemType === 'package' && player.packages.length > 0) {
                            const lostPackage = player.packages.pop();
                            newLog.push(`  ${player.name} spotkal Bandytow! Stracil pakunek: '${lostPackage}'.`);
                            showToast(`${player.name}: Bandyci! Stracil '${lostPackage}'!`);
                        } else if (lostItemType === 'donkey' && player.caravan.length > 1) {
                            const lostDonkey = player.caravan.pop();
                            newLog.push(`  ${player.name} spotkal Bandytow! Stracil osiolka.`);
                            showToast(`${player.name}: Bandyci! Stracil osiolka!`);
                        } else {
                            newLog.push(`  ${player.name} spotkal Bandytow, ale nic nie stracil (brak pakunkow/osiolkow).`);
                            showToast(`${player.name}: Bandyci... ale nic nie stracil!`);
                        }
                    }
                    break;
                case 'well':
                    const wellOutcome = Math.random();
                    if (wellOutcome < 0.4) {
                        newLog.push(`  ${player.name} znalazl Studnie! Zyskuje nowego osiolka!`);
                        showToast(`${player.name}: Studnia! Nowy osiolek!`);
                        const donkeyTypes = ['zwykly', 'twardziel', 'zlodziej', 'prorok', 'wloczega'];
                        const newDonkeyType = donkeyTypes[Math.floor(Math.random() * donkeyTypes.length)];
                        player.caravan.push({ x: player.caravan[player.caravan.length - 1].x, y: player.caravan[player.caravan.length - 1].y, osiolek: Osiolek(newDonkeyType) });
                        if (newDonkeyType !== 'zwykly') {
                            player.donkeyAbilities.push(newDonkeyType);
                        }
                    } else if (wellOutcome < 0.7) {
                        player.extraMoveNextTurn += 1;
                        newLog.push(`  ${player.name} znalazl Studnie! Zyskuje +1 ruch w nastepnej turze.`);
                        showToast(`${player.name}: Studnia! +1 ruch!`);
                    } else {
                        player.losesTurn += 1;
                        newLog.push(`  ${player.name} znalazl Studnie! Niestety, traci 1 ture.`);
                        showToast(`${player.name}: Studnia... Traci ture!`);
                    }
                    break;
                case 'oasis':
                    player.extraMoveNextTurn += 1;
                    newLog.push(`  ${player.name} wszedl na Oaze! Zyskuje +1 ruch w tej turze!`);
                    showToast(`${player.name}: Oaza! +1 ruch!`);
                    break;
                case 'fishing_village':
                    newLog.push(`  ${player.name} wszedl do Wioski Rybakow! Zyskuje pakunek "Ryby".`);
                    showToast(`${player.name}: Wioska Rybakow!`);
                    player.packages.push('Ryby');
                    player.points += 20; // Ryby are worth more
                    break;
                case 'hermitage':
                    newLog.push(`  ${player.name} wszedl do Pustelni! Moze wymienic pakunek na punkty.`);
                    showToast(`${player.name}: Pustelnia! Wymiana pakunkow!`);
                    if (player.packages.length > 0) {
                        const soldPackage = player.packages.pop();
                        player.points += 15; // Better rate than bazaar
                        newLog.push(`  ${player.name} wymienil '${soldPackage}' za 15 punktow.`);
                        showToast(`${player.name}: Wymienil '${soldPackage}' w pustelni!`);
                    } else {
                        newLog.push("  Nie masz pakunkow do wymiany.");
                    }
                    break;
                case 'mystery_shrine':
                    const shrineOutcome = Math.random();
                    if (shrineOutcome < 0.5) {
                        newLog.push(`  ${player.name} znalazl Kapliczke! Zyskuje blyskawiczny bonus do ruchu (+2).`);
                        showToast(`${player.name}: Kapliczka! +2 ruch!`);
                        player.extraMoveNextTurn += 2;
                    } else {
                        newLog.push(`  ${player.name} znalazl Kapliczke! Zostaje przeklety - traci pakunek i ture.`);
                        showToast(`${player.name}: Kapliczka! Przeklenstwo!`);
                        if (player.packages.length > 0) {
                            player.packages.pop();
                        }
                        player.losesTurn += 1;
                    }
                    break;
                default:
                    break;
            }

            // 'Zlodziej' (Thief) Donkey activation (if player has it and another player has packages)
            if (hasAbility(player, 'zlodziej')) {
                const targetPlayer = playersList.find(p => p.name !== player.name && p.packages.length > 0);
                if (targetPlayer) {
                     if (Math.random() < 0.3) { // 30% chance to activate thief ability
                        const stolenPackage = targetPlayer.packages.pop();
                        player.packages.push(stolenPackage);
                        player.points += 5; // Bonus for stealing
                        newLog.push(`  ${player.name} (Zlodziej) ukradl '${stolenPackage}' od ${targetPlayer.name}! Zyskal 5 punktow.`);
                        showToast(`${player.name}: Ukradl '${stolenPackage}'!`);
                     }
                }
            }

            gameLog.push(...newLog); // Add new logs to the main game log
            updateGameLogUI();
        };

        // Utility to find a loose donkey within a given radius
        const findClosestLooseDonkey = (player, board, size, radius) => {
            const { x: playerX, y: playerY } = player.caravan[0];
            let closestDonkey = null;
            let minDistance = Infinity;

            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (board[r][c].type === 'donkey') {
                        const dist = calculateManhattanDistance(playerX, playerY, r, c);
                        if (dist <= radius && dist < minDistance) {
                            minDistance = dist;
                            closestDonkey = { x: r, y: c };
                        }
                    }
                }
            }
            return closestDonkey;
        };

        // Utility to find an empty adjacent tile
        const findEmptyAdjacentTile = (x, y, board, size) => {
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (const [dx, dy] of directions) {
                const newX = x + dx;
                const newY = y + dy;
                if (newX >= 0 && newX < size && newY >= 0 && newY < size && board[newX][newY].type === 'empty') {
                    return { x: newX, y: newY };
                }
            }
            return null;
        };

        // Function to use the Bell equipment
        const useBell = (player, board, size) => {
            if (!hasEquipment(player, 'dzwonek') || player.bellCooldown > 0) {
                gameLog.push(`  ${player.name}: Nie mozesz teraz uzyc Dzwonka.`);
                showToast(`${player.name}: Dzwonek nieaktywny!`);
                updateGameLogUI();
                return;
            }

            const closestDonkey = findClosestLooseDonkey(player, board, size, 2); // Radius of 2 for Bell
            if (closestDonkey) {
                const emptyAdjacent = findEmptyAdjacentTile(player.caravan[0].x, player.caravan[0].y, board, size);
                if (emptyAdjacent) {
                    // Move the donkey
                    board[emptyAdjacent.x][emptyAdjacent.y] = Pole('donkey', 'ðŸ´');
                    board[closestDonkey.x][closestDonkey.y] = Pole('empty', '.');
                    gameLog.push(`  ${player.name} uzyl Dzwonka! Przyciagnal luznego osiolka z (${closestDonkey.x + 1}, ${closestDonkey.y + 1}) na pole (${emptyAdjacent.x + 1}, ${emptyAdjacent.y + 1}).`);
                    showToast(`${player.name}: Uzyto Dzwonka!`);
                    player.bellCooldown = 3; // Set cooldown
                } else {
                    gameLog.push(`  ${player.name}: Brak wolnego pola obok karawany, aby przyciagnac osiolka.`);
                    showToast(`${player.name}: Brak miejsca na osiolka!`);
                }
            } else {
                gameLog.push(`  ${player.name}: W poblizu nie ma luznych osiolkow, by uzyc Dzwonka.`);
                showToast(`${player.name}: Brak osiolkow w poblizu!`);
            }
            updateGameLogUI();
            renderGame(); // Re-render board and UI
        };

        // Finds the closest interesting tile for Prorok ability
        const findClosestInterestingTile = (player, board, size, maxDistance = 3) => {
            const { x: currentX, y: currentY } = player.caravan[0];
            let closestTile = null;
            let minDistance = Infinity;

            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const tile = board[r][c];
                    const distance = calculateManhattanDistance(currentX, currentY, r, c);

                    if (distance > 0 && distance <= maxDistance) {
                        if (tile.type === 'package' || tile.type === 'food' || tile.type === 'donkey' || tile.type === 'special_donkey') {
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestTile = { x: r, y: c, type: tile.type, symbol: tile.symbol };
                            }
                        }
                    }
                }
            }
            return closestTile;
        };


        // Calculates possible moves for a player
        const calculatePossibleMoves = (player, board, size) => {
            const { x: currentX, y: currentY } = player.caravan[0];
            let possibleMoves = [];
            let baseMovement = 2; // Default movement

            // Add movement bonus from vineyard, equipment, or Mapa
            baseMovement += player.extraMoveNextTurn;
            if (hasEquipment(player, 'sakwa') || player.role === 'Odkrywca') {
                baseMovement += 1;
            }
            if (player.mapaBonusActive) { // Permanent +1 movement from Mapa
                baseMovement += 1;
            }
            
            const actualMovement = Math.max(1, baseMovement);

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // Up, Down, Right, Left

            for (const [dx, dy] of directions) {
                for (let step = 1; step <= actualMovement; step++) {
                    const nextX = currentX + dx * step;
                    const nextY = currentY + dy * step;

                    if (nextX >= 0 && nextX < size && nextY >= 0 && nextY < size) {
                        const tile = board[nextX][nextY];
                        let cost = step;

                        // Cactus costs 1 extra move, UNLESS player has 'wloczega' ability
                        if (tile.type === 'cactus' && !hasAbility(player, 'wloczega')) {
                            cost += 1;
                        }
                        
                        // Check for blocked paths
                        let blockedPath = false;
                        for (let i = 1; i <= step; i++) {
                            const intermediateX = currentX + dx * i;
                            const intermediateY = currentY + dy * i;
                            if (intermediateX < 0 || intermediateX >= size || intermediateY < 0 || intermediateY >= size) {
                                blockedPath = true; // Path out of bounds is blocked
                                break;
                            }
                            const intermediateTile = board[intermediateX][intermediateY];
                            if (intermediateTile.type === 'fence' || (intermediateTile.type === 'river' && intermediateTile.type !== 'bridge')) {
                                blockedPath = true;
                                break;
                            }
                        }
                        if(blockedPath) continue;
                        
                        if (cost <= actualMovement) {
                            possibleMoves.push({ x: nextX, y: nextY, cost: cost });
                        }
                    }
                }
            }
            return possibleMoves;
        };

        // AI movement logic
        const aiMove = (player, board, playersList, size) => {
            const { x: currentX, y: currentY } = player.caravan[0];
            let currentTurnPossibleMoves = calculatePossibleMoves(player, board, size);
            
            player.extraMoveNextTurn = 0;


            if (currentTurnPossibleMoves.length === 0) {
                gameLog.push(`  ${player.name} (AI) has no possible moves.`);
                showToast(`${player.name} (AI) nie ma ruchow.`);
                updateGameLogUI();
                return;
            }

            let bestMove = null;
            let highestPriority = -Infinity;

            // --- AI Decision Making ---
            // 1. Prioritize using Bell if available and useful
            if (hasEquipment(player, 'dzwonek') && player.bellCooldown === 0) {
                const closestLooseDonkey = findClosestLooseDonkey(player, board, size, 2);
                if (closestLooseDonkey) {
                    const emptyAdjacent = findEmptyAdjacentTile(player.caravan[0].x, player.caravan[0].y, board, size);
                    if (emptyAdjacent) {
                        useBell(player, board, size);
                        return;
                    }
                }
            }
            
            // 2. Evaluate moves based on tile priority
            for (const move of currentTurnPossibleMoves) {
                const { x: targetX, y: targetY } = move;
                const tile = board[targetX][targetY];
                let priority = 0;

                // AI Priorities
                switch (tile.type) {
                    case 'package':
                        priority = 10;
                        if (tile.bonus.name === 'Skarb') priority = 15;
                        if (tile.bonus.name === 'Amulet') priority = 12;
                        if (tile.bonus.name === 'Mapa') priority = 11;
                        break;
                    case 'special_donkey':
                        priority = 9;
                        break;
                    case 'food':
                        priority = 8;
                        if (player.caravan.length >= 5) priority = 2;
                        break;
                    case 'donkey':
                        priority = 7;
                        if (player.caravan.length >= 5) priority = 1;
                        break;
                    case 'bazar':
                        priority = player.packages.length > 0 ? 6 : 0;
                        break;
                    case 'vineyard':
                    case 'oasis':
                    case 'well':
                        priority = 5;
                        break;
                    case 'hermitage':
                        priority = player.packages.length > 0 ? 8 : 1;
                        break;
                    case 'fishing_village':
                        priority = 9;
                        break;
                    case 'mountain_shortcut':
                        const { targetX: shortcutTargetX, targetY: shortcutTargetY } = tile.bonus;
                        const shortcutTargetTile = board[shortcutTargetX][shortcutTargetY];
                        if (shortcutTargetTile && shortcutTargetTile.type !== 'empty') {
                            priority = 9.5;
                        } else {
                            priority = 4;
                        }
                        break;
                    case 'trap':
                        if (player.amuletActiveTurns > 0 || hasAbility(player, 'twardziel')) {
                            priority = 3;
                        } else {
                            priority = -10;
                        }
                        break;
                    case 'bandits':
                        if (player.amuletActiveTurns > 0 || hasAbility(player, 'sturdy')) {
                            priority = 4;
                        } else {
                            priority = -8;
                        }
                        break;
                    case 'cactus':
                        if (hasAbility(player, 'wloczega')) {
                            priority = 2;
                        } else {
                            priority = -2;
                        }
                        break;
                    case 'river':
                    case 'fence':
                        priority = -10;
                        break;
                    default:
                        priority = 0;
                        break;
                }

                if (hasAbility(player, 'prorok') && player.prophetRevealedTile) {
                    const { x: rx, y: ry } = player.prophetRevealedTile;
                    const distanceToRevealed = calculateManhattanDistance(targetX, targetY, rx, ry);
                    if (distanceToRevealed < calculateManhattanDistance(currentX, currentY, rx, ry)) {
                        priority += 0.5;
                    }
                }

                priority -= (calculateManhattanDistance(currentX, currentY, targetX, targetY) * 0.1);

                if (priority > highestPriority) {
                    highestPriority = priority;
                    bestMove = move;
                }
            }

            if (bestMove) {
                const oldCaravan = JSON.parse(JSON.stringify(player.caravan));
                player.caravan[0] = { x: bestMove.x, y: bestMove.y, osiolek: oldCaravan[0].osiolek };
                for (let i = 1; i < player.caravan.length; i++) {
                    player.caravan[i] = { ...oldCaravan[i - 1], osiolek: oldCaravan[i].osiolek };
                }
                gameLog.push(`  ${player.name} (AI) moves to (${bestMove.x + 1}, ${bestMove.y + 1}).`);
                showToast(`${player.name} (AI) rusza sie.`);
                handleTileAction(player, board, playersList);
            } else {
                const safeMoves = currentTurnPossibleMoves.filter(move => {
                    const tile = board[move.x][move.y];
                    const isTrapSafe = tile.type !== 'trap' || player.amuletActiveTurns > 0 || hasAbility(player, 'twardziel');
                    const isBanditSafe = tile.type !== 'bandits' || player.amuletActiveTurns > 0 || hasAbility(player, 'sturdy');
                    const isImpassable = tile.type === 'fence' || (tile.type === 'river' && tile.type !== 'bridge');
                    return isTrapSafe && isBanditSafe && !isImpassable;
                });
                if (safeMoves.length > 0) {
                    const randomMove = safeMoves[Math.floor(Math.random() * safeMoves.length)];
                    const oldCaravan = JSON.parse(JSON.stringify(player.caravan));
                    player.caravan[0] = { x: randomMove.x, y: randomMove.y, osiolek: oldCaravan[0].osiolek };
                    for (let i = 1; i < player.caravan.length; i++) {
                        player.caravan[i] = { ...oldCaravan[i - 1], osiolek: oldCaravan[i].osiolek };
                    }
                    gameLog.push(`  ${player.name} (AI) makes a random safe move to (${randomMove.x + 1}, ${randomMove.y + 1}).`);
                    showToast(`${player.name} (AI) wykonuje losowy ruch.`);
                    handleTileAction(player, board, playersList);
                } else {
                     gameLog.push(`  ${player.name} (AI) has no safe moves and stays put.`);
                     showToast(`${player.name} (AI) zostaje w miejscu.`);
                }
            }
            updateGameLogUI();
        };

        // Bandit NPC logic
        const moveBandit = () => {
            // Find the closest player to the bandit
            let closestPlayer = null;
            let minDistance = Infinity;

            players.forEach(player => {
                const dist = calculateManhattanDistance(bandit.x, bandit.y, player.caravan[0].x, player.caravan[0].y);
                if (dist < minDistance) {
                    minDistance = dist;
                    closestPlayer = player;
                }
            });

            if (closestPlayer) {
                const targetX = closestPlayer.caravan[0].x;
                const targetY = closestPlayer.caravan[0].y;
                const dx = Math.sign(targetX - bandit.x);
                const dy = Math.sign(targetY - bandit.y);

                if (Math.random() < 0.5) {
                    if (dx !== 0) bandit.x += dx;
                    else if (dy !== 0) bandit.y += dy;
                } else {
                    if (dy !== 0) bandit.y += dy;
                    else if (dx !== 0) bandit.x += dx;
                }
            }
            gameLog.push(`Bandyta przemiescil sie na pole (${bandit.x + 1}, ${bandit.y + 1}).`);
        };

        // Checks for a bandit encounter
        const checkBanditEncounter = (player) => {
            if (player.caravan[0].x === bandit.x && player.caravan[0].y === bandit.y) {
                gameLog.push(`  ${player.name} spotkal bandyte na polu (${bandit.x + 1}, ${bandit.y + 1})!`);
                showToast(`${player.name}: Spotkal bandyte!`);
                if (player.amuletActiveTurns > 0) {
                    gameLog.push(`  ${player.name} zostal ochroniony przez Amulet!`);
                    showToast(`${player.name}: Amulet chroni!`);
                } else if (hasAbility(player, 'sturdy')) {
                    gameLog.push(`  ${player.name} zostal ochroniony przez Twardego OsioÅ‚ka!`);
                    showToast(`${player.name}: Twardy Osiolek chroni!`);
                } else {
                    const lostItemType = Math.random() < 0.5 ? 'package' : 'donkey';
                    if (lostItemType === 'package' && player.packages.length > 0) {
                        const lostPackage = player.packages.pop();
                        gameLog.push(`  ${player.name} stracil pakunek '${lostPackage}'.`);
                        showToast(`${player.name}: Stracil pakunek!`);
                    } else if (lostItemType === 'donkey' && player.caravan.length > 1) {
                        const lostDonkey = player.caravan.pop();
                        gameLog.push(`  ${player.name} stracil osiolka.`);
                        showToast(`${player.name}: Stracil osiolka!`);
                    } else {
                        gameLog.push(`  ${player.name} nic nie stracil.`);
                        showToast(`${player.name}: Nic nie stracil!`);
                    }
                }
                updateGameLogUI();
            }
        };

        // --- GLOBAL GAME STATE ---
        let board = [];
        let players = [];
        let currentPlayerIndex = 0;
        let gameLog = [];
        let gameOver = false;
        let winner = null;
        let selectedMove = null;
        let turnCounter = 0;
        let eventModalOpen = false;

        // --- GAME INITIALIZATION ---
        function startGame() {
            board = initializeBoard(BOARD_SIZE);
            players = [
                Gracz("Burrito", "ðŸ”µ", "ðŸŸ¦", 0, 0, false), // Human player
                Gracz("Czerwony", "ðŸ”´", "ðŸŸ¥", BOARD_SIZE - 1, BOARD_SIZE - 1, true)  // AI player
            ];
            players[0].equipment.push('sakwa', 'dzwonek');
            players[1].donkeyAbilities.push('prorok', 'wloczega');
            players[0].role = roles[Math.floor(Math.random() * roles.length)].name;
            players[1].role = roles[Math.floor(Math.random() * roles.length)].name;

            currentPlayerIndex = 0;
            turnCounter = 0;
            gameLog = ["--- Rozpoczynamy Karawane Burrito! ---"];
            gameLog.push(`--- Twoja rola: ${players[0].role} ---`);
            gameOver = false;
            winner = null;
            selectedMove = null;
            players[0].shadowTarget = null;

            gameModal.classList.add('hidden');
            gameContainer.classList.remove('hidden');

            renderGame();
            nextTurnButton.classList.remove('hidden');
            restartButton.classList.add('hidden');
            gameStatusElement.textContent = '';
            showToast("Gra rozpoczeta!");
        }

        // --- UI RENDERING FUNCTIONS ---

        // Renders the game board
        function renderGameBoard() {
            gameBoardElement.innerHTML = '';
            board.forEach((row, rIdx) => {
                row.forEach((tile, cIdx) => {
                    const tileDiv = document.createElement('div');
                    tileDiv.classList.add('grid-item');

                    // Highlight possible moves for human player
                    if (!players[currentPlayerIndex].isAI && !players[currentPlayerIndex].shadowTarget) {
                        if (possibleMoves.some(m => m.x === rIdx && m.y === cIdx)) {
                            tileDiv.classList.add('bg-lime-200', 'cursor-pointer', 'hover:bg-lime-300');
                            tileDiv.onclick = () => handleTileClick(rIdx, cIdx);
                        }
                    } else if (!players[currentPlayerIndex].isAI && players[currentPlayerIndex].shadowTarget) {
                        // Shadow Donkey ability
                        if (board[rIdx][cIdx].type === 'package') {
                            tileDiv.classList.add('bg-purple-200', 'cursor-pointer', 'hover:bg-purple-300');
                            tileDiv.onclick = () => handleTileClick(rIdx, cIdx);
                        }
                        const { x: targetX, y: targetY } = players[currentPlayerIndex].shadowTarget;
                        if (calculateManhattanDistance(targetX, targetY, rIdx, cIdx) === 1 && board[rIdx][cIdx].type === 'empty') {
                             tileDiv.classList.add('bg-purple-200', 'cursor-pointer', 'hover:bg-purple-300');
                            tileDiv.onclick = () => handleTileClick(rIdx, cIdx);
                        }
                    }

                    if (selectedMove && selectedMove.x === rIdx && selectedMove.y === cIdx) {
                        tileDiv.classList.add('bg-yellow-300');
                    }

                    let tileContent = tile.symbol;
                    
                    // Render players
                    let isPlayerHere = false;
                    for (const player of players) {
                        if (player.caravan[0].x === rIdx && player.caravan[0].y === cIdx) {
                            tileContent = `<span class="font-bold text-lg">${player.leaderSymbol}${player.caravan.length}</span>`;
                            if (player.name === "Burrito") tileDiv.classList.add('text-blue-700');
                            if (player.name === "Czerwony") tileDiv.classList.add('text-red-700');
                            isPlayerHere = true;
                            break;
                        } else if (player.caravan.slice(1).some(seg => seg.x === rIdx && seg.y === cIdx)) {
                            tileContent = `<span class="text-sm">${player.caravanSymbol}</span>`;
                            if (player.name === "Burrito") tileDiv.classList.add('text-blue-500');
                            if (player.name === "Czerwony") tileDiv.classList.add('text-red-500');
                            isPlayerHere = true;
                            break;
                        }
                    }

                    // Render bandit on top of tile content
                    let banditSymbol = '';
                    if (!isPlayerHere && bandit.x === rIdx && bandit.y === cIdx) {
                        banditSymbol = `<span class="bandit-symbol">${bandit.symbol}</span>`;
                    }


                    tileDiv.innerHTML = tileContent + banditSymbol;
                    gameBoardElement.appendChild(tileDiv);
                });
            });
        }

        // Renders player information
        function renderPlayersInfo() {
            playersInfoElement.innerHTML = '';
            players.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.classList.add('mb-4', 'p-3', 'rounded-md', 'border');
                if (currentPlayerIndex === index) {
                    playerDiv.classList.add('bg-amber-100', 'border-amber-500', 'border-2', 'shadow-xl', 'scale-102');
                } else {
                    playerDiv.classList.add('bg-gray-50', 'border-gray-200', 'shadow-md');
                }

                const formatName = (name) => name.charAt(0).toUpperCase() + name.slice(1);
                
                const equipmentList = player.equipment.map(eq => {
                    const status = eq === 'dzwonek' && player.bellCooldown > 0 ? ` (C: ${player.bellCooldown})` : '';
                    return `${formatName(eq)}${status}`;
                }).join(', ');
                
                const abilitiesList = player.donkeyAbilities.map(formatName).join(', ');

                playerDiv.innerHTML = `
                    <h3 class="text-lg font-bold flex items-center gap-2">
                        ${player.leaderSymbol} ${player.name} ${player.isAI ? '<span class="text-xs text-gray-600">(AI)</span>' : ''}
                    </h3>
                    <p>Rola: <span class="font-semibold">${player.role}</span></p>
                    <p>Punkty: <span class="font-semibold">${player.points}</span></p>
                    <p>Karawana: <span class="font-semibold">${player.caravan.length} osioÅ‚kÃ³w</span></p>
                    <p>Pakunki: <span class="font-semibold">${player.packages.join(', ') || 'Brak'}</span></p>
                    ${abilitiesList.length > 0 ? `<p>UmiejÄ™tnoÅ›ci: <span class="font-semibold">${abilitiesList}</span></p>` : ''}
                    ${equipmentList.length > 0 ? `<p>Ekwipunek: <span class="font-semibold">${equipmentList}</span></p>` : ''}
                    ${player.losesTurn > 0 ? `<p class="text-red-600 font-semibold animate-pulse">Tracisz ${player.losesTurn} turÄ™/tury!</p>` : ''}
                    ${player.amuletActiveTurns > 0 ? `<p class="text-purple-600 font-semibold">âœ¨ Amulet aktywny: ${player.amuletActiveTurns} tura/tury!</p>` : ''}
                    ${player.mapaBonusActive ? `<p class="text-yellow-600 font-semibold">ðŸ—ºï¸ Bonus z Mapy: +1 ruch!</p>` : ''}
                    ${player.shadowCooldown > 0 ? `<p class="text-gray-600 font-semibold">âš« Czarny OsioÅ‚ek: ${player.shadowCooldown} tura/tury do odnowienia.</p>` : ''}
                    ${hasEquipment(player, 'dzwonek') ? (player.bellCooldown > 0 ? `<p class="text-orange-600 font-semibold">ðŸ”” Dzwonek: ${player.bellCooldown} tura/tury do odnowienia.</p>` : `<p class="text-lime-600 font-semibold">ðŸ”” Dzwonek: Gotowy!</p>`) : ''}
                    ${hasAbility(player, 'prorok') && player.prophetRevealedTile ? `<p class="text-teal-600 font-semibold">ðŸŒŸ Prorok ujawnia: ${formatName(player.prophetRevealedTile.type)} (${player.prophetRevealedTile.symbol}) na (${player.prophetRevealedTile.x + 1}, ${player.prophetRevealedTile.y + 1})</p>` : ''}
                `;
                playersInfoElement.appendChild(playerDiv);
            });
        }

        // Updates the game log UI
        function updateGameLogUI() {
            gameLogElement.innerHTML = '';
            const displayLog = gameLog.slice(Math.max(gameLog.length - 10, 0));
            displayLog.forEach(message => {
                const p = document.createElement('p');
                p.classList.add('bg-stone-50', 'p-1', 'rounded-sm', 'text-gray-800');
                p.textContent = message;
                gameLogElement.appendChild(p);
            });
            gameLogElement.scrollTop = gameLogElement.scrollHeight;
        }

        // Legend Data
        const legendData = [
            { symbol: 'ðŸ”µ', description: 'Lider gracza' },
            { symbol: 'ðŸ”´', description: 'Lider AI' },
            { symbol: 'ðŸŸ¦', description: 'CzÄ™Å›Ä‡ karawany gracza' },
            { symbol: 'ðŸŸ¥', description: 'CzÄ™Å›Ä‡ karawany AI' },
            { symbol: 'ðŸ¤ ', description: 'Bandolero (NPC)' },
            { symbol: 'ðŸ“¦', description: 'Pakunek' },
            { symbol: 'âœ¨', description: 'Amulet/Kapliczka' },
            { symbol: 'ðŸ—ºï¸', description: 'Mapa' },
            { symbol: 'ðŸ´', description: 'LuÅºny osioÅ‚ek' },
            { symbol: 'ðŸŽ', description: 'Jedzenie' },
            { symbol: 'â˜ ï¸', description: 'PuÅ‚apka' },
            { symbol: 'ðŸ‡', description: 'Winnica' },
            { symbol: 'ðŸ”ï¸', description: 'GÃ³rski skrÃ³t' },
            { symbol: 'ðŸŒµ', description: 'Kaktus' },
            { symbol: 'ðŸŒŠ', description: 'Rzeka' },
            { symbol: 'ðŸŒ‰', description: 'Most' },
            { symbol: 'ðŸ’°', description: 'Bazar' },
            { symbol: 'ðŸš§', description: 'PÅ‚ot' },
            { symbol: 'ðŸ’§', description: 'Studnia' },
            { symbol: 'ðŸŒ´', description: 'Oaza' },
            { symbol: 'ðŸŽ£', description: 'Wioska RybakÃ³w' },
            { symbol: 'ðŸ ', description: 'Pustelnia' },
            { symbol: 'âšª', description: 'BiaÅ‚y OsioÅ‚ek (Przewodnik)' },
            { symbol: 'âš«', description: 'Czarny OsioÅ‚ek (CieÅ„)' },
            { symbol: 'ðŸŸ«', description: 'BrÄ…zowy OsioÅ‚ek (Twardziel)' },
            { symbol: 'ðŸŒŸ', description: 'ZÅ‚oty OsioÅ‚ek (Prorok)' },
            { symbol: 'ðŸŽ’', description: 'Zielony OsioÅ‚ek (WÅ‚Ã³czÄ™ga)' },
        ];
        
        // Renders the legend
        function renderLegend() {
            legendInfoElement.innerHTML = '';
            legendData.forEach(item => {
                const div = document.createElement('div');
                div.classList.add('flex', 'items-center', 'gap-2', 'p-1', 'bg-stone-50', 'rounded-sm');
                div.innerHTML = `<span class="font-semibold">${item.symbol}</span> <span>${item.description}</span>`;
                legendInfoElement.appendChild(div);
            });
        }

        // Main rendering function
        function renderGame() {
            renderPlayersInfo();
            if (!players[currentPlayerIndex].isAI) {
                possibleMoves = calculatePossibleMoves(players[currentPlayerIndex], board, BOARD_SIZE);
            } else {
                possibleMoves = [];
            }
            renderGameBoard();
            updateNextTurnButtonState();
        }

        // Updates the state of the "Next Turn" button
        function updateNextTurnButtonState() {
            if (gameOver) {
                nextTurnButton.classList.add('hidden');
                useBellButton.classList.add('hidden');
                useShadowButton.classList.add('hidden');
                restartButton.classList.remove('hidden');
                gameStatusElement.textContent = `Gra zakonczona! Zwyciezca: ${winner}`;
            } else {
                const currentPlayer = players[currentPlayerIndex];
                if (currentPlayer.isAI) {
                    nextTurnButton.textContent = "Tura AI (poczekaj...)";
                    nextTurnButton.disabled = true;
                } else {
                    nextTurnButton.textContent = "Wykonaj Ruch";
                    nextTurnButton.disabled = (!selectedMove && !currentPlayer.shadowTarget);
                }
                
                // Update Use Bell button
                if (!currentPlayer.isAI && hasEquipment(currentPlayer, 'dzwonek')) {
                    useBellButton.classList.remove('hidden');
                    const closestDonkey = findClosestLooseDonkey(currentPlayer, board, BOARD_SIZE, 2);
                    const emptyAdjacent = findEmptyAdjacentTile(currentPlayer.caravan[0].x, currentPlayer.caravan[0].y, board, BOARD_SIZE);
                    useBellButton.disabled = (currentPlayer.bellCooldown > 0 || !closestDonkey || !emptyAdjacent);
                } else {
                    useBellButton.classList.add('hidden');
                }

                // Update Use Shadow button
                if (!currentPlayer.isAI && hasAbility(currentPlayer, 'shadow')) {
                    useShadowButton.classList.remove('hidden');
                    const hasPackages = board.flat().some(tile => tile.type === 'package');
                    useShadowButton.disabled = (currentPlayer.shadowCooldown > 0 || !hasPackages);
                } else {
                    useShadowButton.classList.add('hidden');
                }
            }
        }
        
        // Function to handle event cards
        const handleEventCard = () => {
            if (eventModalOpen) return;
            const randomEvent = eventCards[Math.floor(Math.random() * eventCards.length)];
            eventMessage.textContent = randomEvent.description;
            gameLog.push(`--- Aktywowano zdarzenie: ${randomEvent.name}! ---`);
            showToast(`Karta zdarzenia: ${randomEvent.name}!`);
            
            eventModal.classList.remove('hidden');
            eventModalOpen = true;

            const tempBoard = JSON.parse(JSON.stringify(board));
            const tempPlayers = JSON.parse(JSON.stringify(players));

            randomEvent.effect(tempPlayers, gameLog, tempBoard, BOARD_SIZE);
            
            board = tempBoard;
            players = tempPlayers;

            updateGameLogUI();
            renderGame();
        };

        // --- GAME FLOW ---

        // Handles a player's turn
        function nextTurn() {
            if (gameOver || eventModalOpen) return;

            // Trigger event card every X turns
            if (turnCounter > 0 && turnCounter % EVENT_INTERVAL === 0) {
                handleEventCard();
                return; // Wait for modal close
            }

            let updatedPlayers = JSON.parse(JSON.stringify(players));
            let currentGracz = updatedPlayers[currentPlayerIndex];
            let newBoard = JSON.parse(JSON.stringify(board));

            currentGracz.amuletActiveTurns = Math.max(0, currentGracz.amuletActiveTurns - 1);
            currentGracz.shadowCooldown = Math.max(0, currentGracz.shadowCooldown - 1);
            currentGracz.bellCooldown = Math.max(0, currentGracz.bellCooldown - 1);
            currentGracz.extraMoveNextTurn = 0; // Reset bonus from Oasis/Vineyard

            if (hasAbility(currentGracz, 'prorok')) {
                currentGracz.prophetRevealedTile = findClosestInterestingTile(currentGracz, newBoard, BOARD_SIZE);
            } else {
                currentGracz.prophetRevealedTile = null;
            }

            if (currentGracz.losesTurn > 0) {
                gameLog.push(`  ${currentGracz.name} traci ture. Pozostalo: ${currentGracz.losesTurn - 1}.`);
                showToast(`${currentGracz.name}: Traci ture!`);
                currentGracz.losesTurn -= 1;
                players = updatedPlayers;
                renderPlayersInfo();
                updateGameLogUI();
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                setTimeout(nextTurn, 500);
                return;
            }

            if (!currentGracz.isAI) {
                if (!selectedMove) {
                    gameLog.push(`  ${currentGracz.name}: Wybierz pole, na ktore chcesz sie ruszyc.`);
                    updateGameLogUI();
                    return;
                }
                const oldCaravan = JSON.parse(JSON.stringify(currentGracz.caravan));
                currentGracz.caravan[0] = { x: selectedMove.x, y: selectedMove.y, osiolek: oldCaravan[0].osiolek };
                for (let i = 1; i < currentGracz.caravan.length; i++) {
                    currentGracz.caravan[i] = { ...oldCaravan[i - 1], osiolek: oldCaravan[i].osiolek };
                }
                gameLog.push(`  ${currentGracz.name} ruszyl sie na (${selectedMove.x + 1}, ${selectedMove.y + 1}).`);
                showToast(`${currentGracz.name} ruszyl sie na (${selectedMove.x + 1}, ${selectedMove.y + 1}).`);
                handleTileAction(currentGracz, newBoard, updatedPlayers);
                selectedMove = null;
            } else {
                aiMove(currentGracz, newBoard, updatedPlayers, BOARD_SIZE);
            }

            // Bandit Movement and Encounter Check
            moveBandit();
            checkBanditEncounter(currentGracz);

            board = newBoard;
            players = updatedPlayers;
            turnCounter++;

            const packagesOnBoard = board.flat().filter(tile => tile.type === 'package').length;
            if (packagesOnBoard === 0) {
                gameOver = true;
                const finalScores = players.map(p => ({ name: p.name, points: p.points }));
                const winningScore = Math.max(...finalScores.map(p => p.points));
                const winners = finalScores.filter(p => p.points === winningScore);
                winner = winners.length === 1 ? winners[0].name : "Remis";
                gameLog.push("--- KONIEC GRY! ---");
                gameLog.push(`Zwyciezca: ${winners.length === 1 ? winners[0].name : "Remis"} z ${winningScore} punktami!`);
                showToast("KONIEC GRY!");
                
                modalTitle.textContent = "Koniec Gry!";
                modalMessage.innerHTML = `ZwyciÄ™zca: <strong>${winner}</strong> z <strong>${winningScore}</strong> punktami!`;
                modalButton.textContent = "Zagraj Ponownie";
                modalButton.onclick = startGame;
                gameModal.classList.remove('hidden');
                gameContainer.classList.add('hidden');
                renderGame();
                updateGameLogUI();
                return;
            }

            currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
            renderGame();
            updateGameLogUI();

            if (players[currentPlayerIndex].isAI) {
                setTimeout(nextTurn, 1000);
            }
        }

        // Handles tile clicks (for human player)
        function handleTileClick(x, y) {
            if (gameOver || players[currentPlayerIndex].isAI || eventModalOpen) return;

            const currentGracz = players[currentPlayerIndex];

            if (currentGracz.shadowTarget) {
                const { x: targetX, y: targetY } = currentGracz.shadowTarget;
                if (board[x][y].type === 'empty' && calculateManhattanDistance(targetX, targetY, x, y) === 1) {
                    const pakunekBonus = board[targetX][targetY].bonus;
                    const pakunekSymbol = board[targetX][targetY].symbol;
                    board[x][y] = Pole('package', pakunekSymbol, pakunekBonus);
                    board[targetX][targetY] = Pole('empty', '.');
                    currentGracz.shadowTarget = null;
                    gameLog.push(`  ${currentGracz.name} (Cien) przesunal pakunek na pole (${x + 1}, ${y + 1}).`);
                    showToast(`${currentGracz.name}: Pakunek przesuniety!`);
                    renderGame();
                } else {
                    showToast("Nieprawidlowe pole docelowe dla pakunku!");
                }
            } else {
                const isPossible = possibleMoves.some(move => move.x === x && move.y === y);
                if (isPossible) {
                    selectedMove = { x, y };
                    renderGame();
                } else {
                    showToast(`Nie mozesz ruszyc sie na pole (${x + 1}, ${y + 1}).`);
                    selectedMove = null;
                    renderGame();
                }
            }
        }

        // --- EVENT LISTENERS ---
        nextTurnButton.addEventListener('click', nextTurn);
        restartButton.addEventListener('click', startGame);
        useBellButton.addEventListener('click', () => {
            useBell(players[currentPlayerIndex], board, BOARD_SIZE);
            renderGame();
        });
        useShadowButton.addEventListener('click', () => {
            const currentGracz = players[currentPlayerIndex];
            if (!hasAbility(currentGracz, 'shadow') || currentGracz.shadowCooldown > 0) {
                showToast("Nie mozesz teraz uzyc tej umiejetnosci!");
                return;
            }
            if (currentGracz.shadowTarget) {
                currentGracz.shadowTarget = null;
                showToast("Anulowano uzycie Cienia.");
            } else {
                currentGracz.shadowTarget = true; // Temporary state
                showToast("Wybierz pakunek do przesuniecia.");
            }
            renderGame();
        });
        eventCloseButton.addEventListener('click', () => {
            eventModal.classList.add('hidden');
            eventModalOpen = false;
            nextTurn(); // Continue the game
        });


        // --- INITIAL SETUP ---
        document.addEventListener('DOMContentLoaded', () => {
            gameModal.classList.remove('hidden');
            modalTitle.textContent = "Karawana Burrito - Rozszerzona Wersja";
            modalMessage.innerHTML = "Wyrusz w ekscytujÄ…cÄ… podrÃ³Å¼ przez pustyniÄ™, zbierajÄ…c pakunki i rozbudowujÄ…c swojÄ… karawanÄ™ osioÅ‚kÃ³w! Czy uda Ci siÄ™ zebraÄ‡ najwiÄ™cej punktÃ³w?";
            modalButton.textContent = "Rozpocznij GrÄ™";
            modalButton.onclick = startGame;
            
            renderLegend();
        });

    </script>
</body>
</html>
